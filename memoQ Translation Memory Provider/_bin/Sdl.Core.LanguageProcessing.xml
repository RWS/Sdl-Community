<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sdl.Core.LanguageProcessing</name>
    </assembly>
    <members>
        <member name="M:Sdl.Core.LanguageProcessing.AdvancedTokenization.TokenizesToWords(System.Globalization.CultureInfo)">
            <summary>
            Returns true if tokenization for the culture in question is performed in a word-oriented manner, either because
            the language itself is written with spaces separating words, or advanced tokenization is used to parse
            non-separated strings of characters into distinct words.
            </summary>
            <param name="culture">The culture concerned</param>
            <returns>True if <see cref="!:culture"/> is tokenized to words in the way described, false otherwise.</returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.SpecialTokenIDs">
            <summary>
            Same as HashSet _SpecialTokenIDs, but making sure we construct
            array from it only ones.  Used to split string with placeables.
            (May be in calls to _SpecialTokenIDs we can substite
            calls to this one)
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.SpecialTokensExpression">
            <summary>
            Regexp expression to search string for placeables in a form ({{PL1}}|{{PL2}}| ...|{{PLn}})
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.ComputeSuggestions(System.String)">
            <inheritdoc />
            <summary>
            Computes the suggestions from the given source text.
            </summary>
            <param name="sourceText">source text</param>
            <returns>suggestions</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.ComputeSuggestions(Sdl.LanguagePlatform.Core.Segment)">
            <inheritdoc />
            <summary>
            Computes the suggestions from the given source text.
            </summary>
            <param name="sourceText">source text</param>
            <returns>suggestions</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.AddMappings(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs,System.Boolean,System.Collections.Generic.IList{Sdl.LanguagePlatform.Core.Tokenization.Token})">
            <summary>
            Adds mappings for the given words and merged words.
            </summary>
            <param name="words">words</param>
            <param name="mergedWords">mergedWords</param>
            <param name="mappings">mappings</param>
            <param name="hasSpecialTokens"></param>
            <param name="sourceTokens"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.GetMappings(System.String)">
            <inheritdoc />
            <summary>
            Gets the mappings for the given source text.
            </summary>
            <param name="sourceText">source text</param>
            <returns>mappings</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.GetMappings(Sdl.LanguagePlatform.Core.Segment)">
            <inheritdoc />
            <summary>
            Gets the mappings for the given source text.
            </summary>
            <param name="sourceText">source text</param>
            <returns>mappings</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.GetWords(Sdl.LanguagePlatform.Core.Segment,System.Boolean@)">
            <summary>
            Gets the words from the given source text.
            </summary>
            <param name="sourceText">source text</param>
            <param name="hasSpecialTokens"></param>
            <returns>words</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.GetTokenString(Sdl.LanguagePlatform.Core.Tokenization.Token)">
            <summary>
            Copy of the same method in $\LanguagePlatform\...\Stat\TMXDataEncoder.cs
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.GetStandardTokenizer(System.Globalization.CultureInfo)">
            <summary>
            Creates the standard tokenizer with the given culture.
            </summary>
            <param name="cultureInfo">culture</param>
            <returns>standard tokenizer</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.GetMergedWords(System.Collections.Generic.IList{System.String})">
            <summary>
            Gets the merged words from the given words.
            </summary>
            <param name="words">words</param>
            <returns>merged words</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.GetEncodedLiteralWord(System.String)">
            <summary>
            Gets the encoded literal word for the given word.
            </summary>
            <param name="word">word</param>
            <returns>encoded literal word</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.MeltClitics(System.Collections.Generic.List{System.String},Sdl.Core.LanguageProcessing.AutoSuggest.AbstractAutoSuggestDictionaryAccessor.CliticsInformation)">
            <summary>
            Removes blanks between stripped-off clitics and returns the result.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.FileBasedAutoSuggestDictionaryAccessor.GetConnectionString(System.String)">
            <summary>
            Gets the connection string for the given file path.
            </summary>
            <param name="filePath">file path</param>
            <returns>connection string</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.FileBasedAutoSuggestDictionaryAccessor.AddMappings(System.Data.SQLite.SQLiteConnection,System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs,System.Boolean,System.Collections.Generic.IList{Sdl.LanguagePlatform.Core.Tokenization.Token})">
            <summary>
            Adds mappings using the given connection for the given words and merged words.
            </summary>
            <param name="connection">connection</param>
            <param name="words">words</param>
            <param name="mergedWords">mergedWords</param>
            <param name="mappings">mappings</param>
            <param name="hasSpecialTokens"></param>
            <param name="sourceTokens"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.FileBasedAutoSuggestDictionaryAccessor.GetMappingsSql(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Gets the mapping sql.
            </summary>
            <param name="index">index</param>
            <param name="mergedIndex">merged index</param>
            <returns>mapping sql</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.FileBasedAutoSuggestDictionaryAccessor.AddMappings(System.Data.SQLite.SQLiteConnection,System.String,Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs,System.Boolean,System.Collections.Generic.IList{Sdl.LanguagePlatform.Core.Tokenization.Token})">
            <summary>
            Adds mappings using the given connection and sql.
            </summary>
            <param name="connection">connection</param>
            <param name="sql">sql</param>
            <param name="mappings">mappings</param>
            <param name="hasSpecialTokens"></param>
            <param name="sourceTokens"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.FileBasedAutoSuggestDictionaryAccessor.GetSourceWordsIndex(System.Data.SQLite.SQLiteConnection,System.Collections.Generic.IList{System.String})">
            <summary>
            Gets the source words index using the given connection for the given words.
            </summary>
            <param name="connection">connection</param>
            <param name="words">words</param>
            <returns>source words index</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.FileBasedAutoSuggestDictionaryAccessor.GetSourceWordsIndexSql(System.Collections.Generic.IEnumerable{System.String},System.Int32@)">
            <summary>
            Gets the source words index sql for the given words.
            </summary>
            <param name="words">words</param>
            <param name="nonNull"></param>
            <returns>source words index sql</returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.AutoSuggest.IAutoSuggestDictionaryAccessor">
            <inheritdoc />
            <summary>
            Represents basic access to AutoSuggest dictionaries.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.AutoSuggest.IAutoSuggestDictionaryAccessor.SourceCulture">
            <summary>
            Gets the source culture the accessor is using.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.AutoSuggest.IAutoSuggestDictionaryAccessor.TargetCulture">
            <summary>
            Gets the target culture the accessor is using.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.IAutoSuggestDictionaryAccessor.ComputeSuggestions(Sdl.LanguagePlatform.Core.Segment)">
            <summary>
            Computes the suggestions from the given source text.
            </summary>
            <param name="sourceText">source text</param>
            <returns>suggestions</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.IAutoSuggestDictionaryAccessor.ComputeSuggestions(System.String)">
            <summary>
            Computes the suggestions from the given source text.
            </summary>
            <param name="sourceText">source text</param>
            <returns>suggestions</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.IAutoSuggestDictionaryAccessor.GetMappings(Sdl.LanguagePlatform.Core.Segment)">
            <summary>
            Gets the mappings for the given source text.
            </summary>
            <param name="sourceText">source text</param>
            <returns>mappings</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.IAutoSuggestDictionaryAccessor.GetMappings(System.String)">
            <summary>
            Gets the mappings for the given source text.
            </summary>
            <param name="sourceText">source text</param>
            <returns>mappings</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.IAutoSuggestDictionaryAccessor.GetCommonPhrases(System.String,System.String,System.Int32@)">
            <summary>
            Returns the common phrases which occur in the source and target segment
            </summary>
            <param name="sourceText"></param>
            <param name="targetText"></param>
            <param name="droppedPhrasePairs">Contains the number of dropped phrase pairs (i.e. those contained in the source but not contained in the target)</param>
            <returns>The phrases where the source part occurs in the source text, and the target text occurs in the target text</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.IAutoSuggestDictionaryAccessor.GetCommonPhrases(Sdl.LanguagePlatform.Core.Segment,Sdl.LanguagePlatform.Core.Segment,System.Int32@)">
            <summary>
            Returns the common phrases which occur in the source and target segment. If not tokenized already, the segment will be 
            tokenized using a standard tokenizer.
            </summary>
            <param name="sourceSegment"></param>
            <param name="targetSegment"></param>
            <param name="droppedPhrasePairs">Contains the number of dropped phrase pairs (i.e. those contained in the source but not confirmed by the target)</param>
            <returns>The phrases where the source part occurs in the source text, and the target text occurs in the target text</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.IAutoSuggestDictionaryAccessor.GetCoverage(System.String,System.String)">
            <summary>
            Computes the number of source tokens which are "covered" by phrases which also occur in the target, relative
            to the total number of source tokens. 
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.IAutoSuggestDictionaryAccessor.GetCoverage(Sdl.LanguagePlatform.Core.Segment,Sdl.LanguagePlatform.Core.Segment)">
            <summary>
            Computes the number of source tokens which are "covered" by phrases which also occur in the target, relative
            to the total number of source tokens. 
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs">
            <inheritdoc />
            <summary>
            PhraseMappingPairs class represents a collection of phrase mapping pairs. 
            This collection limits the number of phrase mapping pairs that may associated 
            with one source string.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.#ctor">
            <inheritdoc />
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.#ctor(System.Collections.Generic.IList{Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPair})">
            <inheritdoc />
            <summary>
            Constructor that takes the given phrase mapping pairs.
            </summary>
            <param name="phraseMappingPairs">phrase mapping pairs</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.Add(Sdl.LanguagePlatform.Core.Segment,Sdl.LanguagePlatform.Core.Segment,System.Int32)">
            <summary>
            Adds a phrase mapping pair with the given source, target, and frequency.
            </summary>
            <param name="source">source</param>
            <param name="target">target</param>
            <param name="frequency">frequency</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.ClearItems">
            <inheritdoc />
            <summary>
            Clears all the items.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.InsertItem(System.Int32,Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPair)">
            <inheritdoc />
            <summary>
            Inserts the given item at the given index.
            </summary>
            <param name="index">index</param>
            <param name="item">item</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.RemoveItem(System.Int32)">
            <inheritdoc />
            <summary>
            Removes the item from the given index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.SetItem(System.Int32,Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPair)">
            <inheritdoc />
            <summary>
            Sets the given item at the given index.
            </summary>
            <param name="index">index</param>
            <param name="item">item</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.GetSourceCount(Sdl.LanguagePlatform.Core.Segment)">
            <summary>
            Gets the source count for the given source string. The source count is the 
            number of phrase mapping pairs that corresponds to a given source string.
            </summary>
            <param name="source">source</param>
            <returns>source count</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.IncrementSourceCount(Sdl.LanguagePlatform.Core.Segment)">
            <summary>
            Increments the source count for the given source string.
            </summary>
            <param name="source">source</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.DecrementSourceCount(Sdl.LanguagePlatform.Core.Segment)">
            <summary>
            Decrements the source count for the given source string.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.EnsureSourceCountExists(Sdl.LanguagePlatform.Core.Segment)">
            <summary>
            Ensures the a source count entry exists in the source count dictionary.
            </summary>
            <param name="source">source</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.PhraseMappingPairs.ToString">
            <summary>
            ToString represents the object as a string.
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.Utilities.IndexOf(System.Collections.Generic.IList{Sdl.LanguagePlatform.Core.Tokenization.Token},System.Collections.Generic.IList{Sdl.LanguagePlatform.Core.Tokenization.Token})">
            <summary>
            returns all starting indices of phrase in segment. Note that for certain token classes, only the phrase's type will
            be checked. 
            </summary>
            <param name="phraseTokens"></param>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.Utilities.StartsAt(System.Collections.Generic.IList{Sdl.LanguagePlatform.Core.Tokenization.Token},System.Collections.Generic.IList{Sdl.LanguagePlatform.Core.Tokenization.Token},System.Int32)">
            <summary>
            Checks whether <paramref name="phrase"/> starts at index <paramref name="start"/> in <paramref name="segment"/>. Tags
            and whitespace "inside" the phrase and the segment will be skipped, but not at the start of either. The phrase should
            not contain peripheral whitespace.
            </summary>
            <param name="segment"></param>
            <param name="start"></param>
            <param name="phrase"></param>
            <returns>true iff <paramref name="phrase"/> starts at position <paramref name="start"/> in <paramref name="segment"/></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.AutoSuggest.Utilities.AreTokensCompatible(Sdl.LanguagePlatform.Core.Tokenization.Token,Sdl.LanguagePlatform.Core.Tokenization.Token)">
            <summary>
            Determines whether two tokens are compatible, in terms of phrase identification and lookup. For certain
            token classes (punctuation, placeable classes, whitespace, tags), it is sufficient for the token type
            to be the same. For text-based tokens, the token texts must be identical, ignoring case.
            </summary>
            <param name="phraseToken"></param>
            <param name="segmentToken"></param>
            <returns></returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.CharacterSetParser">
            <summary>
            A parser to create a <see cref="T:Sdl.LanguagePlatform.Core.CharacterSet"/> from its textual representation.
            Simplified Character Sets contain chars, ranges, and Unicode class references. They can be 
            optionally negated. Their string representation is as follows:
            <list type="table">
            <item>cs = '[' Neg? (char | range | class)* ']'</item>
            <item>char = EscapedChar | UnicodeChar | SimpleChar</item>
            <item>Neg = '^'</item>
            <item>range = char '-' char</item>
            <item>EscapedChar = '\' SimpleChar</item>
            <item>UnicodeChar = 'U+' HexDigit{4}</item>
            </list>
            </summary>
            <remarks>This class is internal and not supposed to be used directly in your code.</remarks>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.CharacterSetParser.Parse(System.String,System.Int32@)">
            <summary>
            Attempts to parse a character set, given the input <paramref name="input"/> 
            and starting from the start position <paramref name="p"/>. The position will 
            be updated if the parse is successful and then point to the first character 
            after the closing bracket in the input.
            <param name="input">The input string for the parser</param>
            <param name="p">The current position in the input string</param>
            </summary>
            <returns>A character set, if the parse is successful. If no valid character
            set can be parsed, an exception will be thrown.</returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.CurrencyFSTEx.CurrencyFormats">
            <summary>
            Defines the current formats to be recognized
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.ErrorMessages">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_ConfigurationAbstractType">
            <summary>
              Looks up a localized string similar to A type referenced in the configuration is abstract and cannot be instantiated..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_ConfigurationCannotInstantiateOrCastType">
            <summary>
              Looks up a localized string similar to A type referenced in the configuration could not be instantiated or casted..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_ConfigurationCannotResolveType">
            <summary>
              Looks up a localized string similar to A type referenced in the configuration could not be resolved..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_ConfigurationInvalidType">
            <summary>
              Looks up a localized string similar to A type referenced in the configuration is invalid for the desired operation..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_InvalidLanguageResourceFile">
            <summary>
              Looks up a localized string similar to The language resource file is invalid..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_LanguageResourceFileNotFound">
            <summary>
              Looks up a localized string similar to The language resource file could not be located..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_NoRegionSpecificLanguageFound">
            <summary>
              Looks up a localized string similar to No region-specific language could be found for the specified language..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_ResourceNotAvailable">
            <summary>
              Looks up a localized string similar to The requested language resource cannot be loaded for the specified culture..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentationEmptyRuleSet">
            <summary>
              Looks up a localized string similar to The segmentation rules are empty..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentationIllegalContinuation">
            <summary>
              Looks up a localized string similar to The segmentation rule could not be parsed due to an invalid continuation specifier..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentationIllegalKeywordInRule">
            <summary>
              Looks up a localized string similar to The segmentation rule could not be parsed due to an unknown keyword..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentationInvalidRule">
            <summary>
              Looks up a localized string similar to The segmentation rule is invalid..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentationInvalidVariableName">
            <summary>
              Looks up a localized string similar to The segmentation rule could not be parsed due to an invalid variable reference..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentationNoRulesForLanguage">
            <summary>
              Looks up a localized string similar to No segmentation rules are available for the specified language..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentationRuleDeserializationError">
            <summary>
              Looks up a localized string similar to An error occurred during deserializaton of the segmentation rules..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentationRuleLoadError">
            <summary>
              Looks up a localized string similar to The segmentation rules could not be loaded..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentationTrailingJunk">
            <summary>
              Looks up a localized string similar to The segmentation rule could not be parsed due to trailing junk..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentationUnknownRuleType">
            <summary>
              Looks up a localized string similar to The segmentation rule could not be parsed due to an unknown rule type..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentationUnknownVariable">
            <summary>
              Looks up a localized string similar to A segmentation rule referred to an undefined variable..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_SegmentNotTokenized">
            <summary>
              Looks up a localized string similar to The segment is not tokenized and cannot be processed..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_StemmerErrorInStemmingRule">
            <summary>
              Looks up a localized string similar to The stemming rule cannot be processed..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_TokenizerInvalidCharacterSet">
            <summary>
              Looks up a localized string similar to An invalid character set occurred in a tokenizer rule..
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.ErrorMessages.EMSG_TokenizerInvalidNumericFormat">
            <summary>
              Looks up a localized string similar to An invalid numeric format occurred in a number token..
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.ILogLogger">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.ILogLogger.Log(System.Exception)">
            <summary>
            
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.ILogLogger.Log(System.String)">
            <summary>
            
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.ILogLogger.LogDebug(System.String)">
            <summary>
            
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.ILogLogger.LogError(System.String)">
            <summary>
            
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.ILogLogger.LogWarn(System.String)">
            <summary>
            
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.LogManager">
            <summary>
            
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.LogManager.Instance">
            <summary>
            Singleton property to ensure LogManager is constructed only once
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.LogManager.Logger">
            <summary>
            The nlog instance unique
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.LogManager.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.MeasureFSTEx.UnitDefinitions">
            <summary>
            Defines the label used to recognize a given unit, plus any <see cref="T:Sdl.LanguagePlatform.Core.Tokenization.CustomUnitDefinition"/> defining its behaviour.
            </summary>
            <remarks>If the label matches a built-in measurement type (e.g. 'mm') and its <see cref="T:Sdl.LanguagePlatform.Core.Tokenization.CustomUnitDefinition"/> is null, the built-in behaviour for that type will be used.
            If the label matches a built-in measurement type and its <see cref="T:Sdl.LanguagePlatform.Core.Tokenization.CustomUnitDefinition"/> is not null, its built-in behaviour will be overridden.
            </remarks>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.NLogLogger">
            <inheritdoc />
            <summary>
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.NLogLogger.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.NLogLogger.Log(System.String)">
            <inheritdoc />
            <summary>
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.NLogLogger.Log(System.Exception)">
            <inheritdoc />
            <summary>
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.NLogLogger.LogError(System.String)">
            <inheritdoc />
            <summary>
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.NLogLogger.LogWarn(System.String)">
            <inheritdoc />
            <summary>
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.NLogLogger.LogDebug(System.String)">
            <inheritdoc />
            <summary>
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor">
            <inheritdoc />
            <summary>
            A simple container for individual accessors which implement a sequential lookup order for a specific resource.
            The individual accessors are tried in turn for a resource status and the actual resource data. No merging
            of resources is available. 
            <para>Note that conflicts may exist with the resolution strategy built into each individual accessor. For example, 
            one accessor may fall back to a more generic culture and thus resolve a resource request, while another
            accessor which is further down in the lookup chain may have a resource for the specialized culture.</para>
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance. 
            </summary>
            <param name="addDefaultAccessor">If true, a default <see cref="T:Sdl.Core.LanguageProcessing.Resources.ResourceFileResourceAccessor"/> is added.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor.Insert(System.Int32,Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor)">
            <summary>
            Inserts a new resource data accessor at the specified position in the list of 
            elements.
            </summary>
            <param name="index">The position at which to add the item.</param>
            <param name="racc">The accessor to add.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor.Insert(Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor)">
            <summary>
            Inserts a new resource data accessor at the beginning of the list.
            </summary>
            <param name="racc">The accessor to add.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor.AddDefaultAccessor">
            <summary>
            Adds a default <see cref="T:Sdl.Core.LanguageProcessing.Resources.ResourceFileResourceAccessor"/> at
            the end of the list giving it the least priority.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor.Add(Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor)">
            <summary>
            Adds the accessor to the list of individual accessors. The item will be added
            at the end of the accessor list, giving it lower priority than the preceding items.
            </summary>
            <param name="racc">The accessor to add.</param>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor.Count">
            <summary>
            Returns the number of individual accessors configured for this instance.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor.Item(System.Int32)">
            <summary>
            Gets the accessor at the specified index.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor.GetResourceStatus(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor.GetResourceStatus(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)" />. The
            status returned is the status returned by the first accessor which differs from 
            <see cref="F:Sdl.LanguagePlatform.Core.Resources.ResourceStatus.NotAvailable" />.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor.ReadResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor.ReadResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)" />. 
            The data returned is the data returned by the first accessor which has available data.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor.GetResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor.GetResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)" />.
            The data returned is the data returned by the first accessor which has available data.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.CompositeResourceDataAccessor.GetSupportedCultures(Sdl.LanguagePlatform.Core.Resources.LanguageResourceType)">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor.GetSupportedCultures(Sdl.LanguagePlatform.Core.Resources.LanguageResourceType)" />. 
            The list of supported cultures is the combination of supported cultures of all individual
            accessors for the specified resource type.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Resources.LanguageResources">
            <summary>
            This class collects and caches language-specific resources, such as stop word lists, 
            prefix lists, and others and provides convenient access to the resources. All methods 
            are typically read-only. 
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Resources.LanguageResources.StoplistSignature">
            <summary>
            Return a signature to distinguish use of this stoplist
            (typically for detecting reindex requirements)
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Resources.ResourceFileResourceAccessor">
            <inheritdoc />
            <summary>
            Implements a resource accessor which retrieves resources from the default (fallback)
            resources file (Sdl.LanguagePlatform.NLP.resources)
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Resources.ResourceFileResourceAccessor.DefaultResourceFileName">
            <summary>
            The file name of the default resource file
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceFileResourceAccessor.#ctor(System.String)">
            <inheritdoc />
            <summary>
            Initializes a new instance with the specified values.
            </summary>
            <param name="resourceFileName">The path to the resource file to use</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceFileResourceAccessor.#ctor">
            <inheritdoc />
            <summary>
            Initializes a new instance, using default values. The path to the resource file
            is determined by a search heuristics which searches several standard locations in which 
            the resource file may be located. The usual location is the where the current assembly
            is located. An exception is thrown if the resource file isn't found.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceFileResourceAccessor.GetResourceFile">
            <summary>
            Attempts to locate the resource file in a variety of locations. The first one is returned.
            This method can be used to test whether the resource file can be located before instantiating 
            the accessor.
            </summary>
            <returns>A resource file location, if it exists, and null otherwise.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceFileResourceAccessor.GetResourceLocation(System.String)">
            <summary>
            Checks the specified loadpath for the resource file, returns the full filepath if it's there or an empty string if it's not.
            </summary>
            <param name="loadPath"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceFileResourceAccessor.GetAllResourceKeys">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetAllResourceKeys" />
            </summary>
            <returns>The list of resource keys known to the storage.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceFileResourceAccessor.ReadResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.ReadResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)" />
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceFileResourceAccessor.GetResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)" />
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Resources.ResourceStorage">
            <inheritdoc />
            <summary>
            An abstract base class which provides functionality to retrieve resources stored in 
            some key-value container. That container may be the file system, an assembly, a 
            database, or a resources file. The class standardizes the resource key and naming 
            conventions for the resources.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.#ctor">
            <inheritdoc />
            <summary>
            Initializes a new instance with default values.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.#ctor(System.String)">
            <summary>
            Initializes a new instance with the specified values.
            </summary>
            <param name="keyPrefix">An optional prefix which is prepended to each resource
            key prior to lookup</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetAllResourceKeys">
            <summary>
            Returns the keys of the stored resources as a list of strings.
            </summary>
            <returns>The list of resource keys known to the storage.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.ReadResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor.ReadResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)" />
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor.GetResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)" />
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetResourceTypeName(Sdl.LanguagePlatform.Core.Resources.LanguageResourceType)">
            <summary>
            Gets the standardized resource key name for the specified language resource type, 
            without an added prefix.
            </summary>
            <param name="t">The language resource type</param>
            <returns>The standardized resource key name for the specified language resource type</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.LoadWordlist(Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor,System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)">
            <summary>
            Returns the resource data for the required resource as a word list. If the stored 
            resource is not a word list, an exception will be thrown.
            </summary>
            <param name="accessor">The resource data accessor to use to retrieve the data</param>
            <param name="culture">The culture to obtain the resource for</param>
            <param name="t">The type of the language resource to retrieve</param>
            <param name="fallback">Whether or not to use a fallback stragegy if specific
            resources cannot be found (see <see cref="M:Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor.ReadResourceData(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)"/>)</param>
            <returns>The requested data as a word list</returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.KeyPrefix">
            <summary>
            Gets the configured key prefix, which may be null.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetName(System.String,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType)">
            <summary>
            Computes the full resource key name, which is a combination of the optional <see cref="P:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.KeyPrefix"/>,
            the <paramref name="culturePrefix"/>, and the standardized resource key name (see <see cref="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetResourceTypeName(Sdl.LanguagePlatform.Core.Resources.LanguageResourceType)"/>).
            </summary>
            <param name="culturePrefix">An optional prefix which usually is the culture code (e.g. "en-US")</param>
            <param name="t">The language resource type for which to get the resource key</param>
            <returns>The full language resource key</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetName(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType)">
            <summary>
            Computes the full resource key name, which is a combination of the optional <see cref="P:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.KeyPrefix"/>,
            the name of the provided <paramref name="culture"/>, and the standardized resource key name (see <see cref="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetResourceTypeName(Sdl.LanguagePlatform.Core.Resources.LanguageResourceType)"/>).
            </summary>
            <param name="culture">An optional culture. If supplied, the culture's name will be used to compute the resource key.</param>
            <param name="t">The language resource type for which to get the resource key</param>
            <returns>The full language resource key</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetResourceName(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)">
            <summary>
            Gets the resource key name, given a culture and the language resource type. Optionally 
            the following search strategy is applied if resources for the exact culture cannot be found:
            <list type="ordered">
            <item>First, it is checked whether data for the exact culture is available.</item>
            <item>If not, data is continually requested for the culture's parent culture, 
            until the parent culture is the invariant culture, or undefined.</item>
            <item>Data is then requested for the culture's language group.</item>
            <item>Finally, data is requested for the invariant culture (<see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>)</item>
            </list>
            The first resource key for which data is available is then returned, or <c>null</c> if no data can be found.
            </summary>
            <param name="culture">The culture for which to retrieve resource data</param>
            <param name="t">The type of the language resource to retrieve</param>
            <param name="fallback">If <c>true</c>, a fallback search strategy is applied to find
            resources for compatible, but less specific resource data.</param>
            <returns>The full resource key for the language resource, or <c>null</c> if 
            no data is available.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetSupportedCultures(Sdl.LanguagePlatform.Core.Resources.LanguageResourceType)">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor.GetSupportedCultures(Sdl.LanguagePlatform.Core.Resources.LanguageResourceType)" />
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Resources.ResourceStorage.GetResourceStatus(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor.GetResourceStatus(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.LanguageResourceType,System.Boolean)" />
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.BomNode.Split">
            <inheritdoc />
            <summary>
            does tree split on node position, the bilingual container split, and synchronize the paragraph with the tree
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.BomNode.Split(System.Boolean)">
            <summary>
            Splits the container at the given node. The node and everything to the right of it
            will be moved into the second half, everything else will remain in the first half.
            </summary>
            <param name="promoteDataToParent"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.BomNode.SplitText(System.Int32,System.Boolean)">
            <summary>
            Splits a text item
            </summary>
            <param name="splitPosition"></param>
            <param name="leadingSpaces"></param>
            <returns></returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.BomSegmentationTreeManager">
            <summary>
            This class manages the tree which is overlaid on the FF2 Bilingual Object Model in
            order to assist in segmentation of the FF2 B.O.M.
            It has methods which support creation of starters/enders and iteration over starters
            and enders. Additional support methods are present.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.BomSegmentationTreeManager.Tree">
            <summary>
            The tree which is overlaid onto the FF2 Bilingual Object Model
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.BomSegmentationTreeManager.PopulateTree(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupDataContainer)">
            <summary>
            Populates a tree based on the FF2 Bilingual Object Model object passed in.
            Note: The root container is not added to the tree
            </summary>
            <param name="rootContainer">The FF2 Bilingual Object Model container</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.BomSegmentationTreeManager.PopulateTreeWithRoot(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData)">
            <summary>
            Populates a tree based on the FF2 Bilingual Object Model object passed in.
            Note: The root container is added to the tree unless it is of type IParagraph
            </summary>
            <param name="root"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.BomSegmentationTreeManager.PopulateItem(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData)">
            <summary>
            Populates an item in the tree
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.BomSegmentationTreeManager.PopulateContainer(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData)">
            <summary>
            Populates a container in the tree
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.BomSegmentationTreeManager.FindNextStarter">
            <summary>
            Finds the next starter
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.BomSegmentationTreeManager.FindNextEnder">
            <summary>
            Finds the next ender
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.CheckContainsSegmentVisitor.VisitCommentMarker(Sdl.FileTypeSupport.Framework.BilingualApi.ICommentMarker)">
            <summary>
            Visit comment marker
            </summary>
            <param name="commentMarker">comment marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.CheckContainsSegmentVisitor.VisitLocationMarker(Sdl.FileTypeSupport.Framework.BilingualApi.ILocationMarker)">
            <summary>
            Visit location marker
            </summary>
            <param name="location">location marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.CheckContainsSegmentVisitor.VisitLockedContent(Sdl.FileTypeSupport.Framework.BilingualApi.ILockedContent)">
            <summary>
            Visit locked content 
            </summary>
            <param name="lockedContent">locked content marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.CheckContainsSegmentVisitor.VisitOtherMarker(Sdl.FileTypeSupport.Framework.BilingualApi.IOtherMarker)">
            <summary>
            Visit other marker
            </summary>
            <param name="marker">other marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.CheckContainsSegmentVisitor.VisitPlaceholderTag(Sdl.FileTypeSupport.Framework.BilingualApi.IPlaceholderTag)">
            <summary>
            Visit and store placeholder tag.
            </summary>
            <param name="tag"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.CheckContainsSegmentVisitor.VisitRevisionMarker(Sdl.FileTypeSupport.Framework.BilingualApi.IRevisionMarker)">
            <summary>
            Visit revision marker.
            </summary>
            <param name="revisionMarker">revision marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.CheckContainsSegmentVisitor.VisitSegment(Sdl.FileTypeSupport.Framework.BilingualApi.ISegment)">
            <summary>
            Visit segment.
            </summary>
            <param name="segment">Segment to be visited.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.CheckContainsSegmentVisitor.VisitTagPair(Sdl.FileTypeSupport.Framework.BilingualApi.ITagPair)">
            <summary>
            Visit tag pair.
            </summary>
            <param name="tagPair">Tag pair to be visited.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.CheckContainsSegmentVisitor.VisitText(Sdl.FileTypeSupport.Framework.BilingualApi.IText)">
            <summary>
            Visit text.
            </summary>
            <param name="text">Text to be visited.</param>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.ChunkType.Whitespace">
            <summary>
            Leading whitespace or neutral (leading) chunk
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.ChunkType.BreakAfter">
            <summary>
            A break occurs after this chunk
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.ChunkType.Text">
            <summary>
            Text chunk, i.e. a text segment without a segment break
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.SegmentationMethod">
            <summary>
            Describes the method used to compute a chunk's boundaries.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.SegmentationMethod.Rule">
            <summary>
            A segmentation rule was applied.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.SegmentationMethod.Whitespace">
            <summary>
            Unbound, separate whitespace (leading or trailing).
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.SegmentationMethod.EndOfInput">
            <summary>
            The end of input or paragraph has been reached.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.Chunk">
            <inheritdoc />
            <summary>
            A chunk represents a piece of text, identified by the text offsets
            in the input string. 
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.ContentIterator.#ctor(Sdl.FileTypeSupport.Framework.BilingualApi.Location,System.Collections.Generic.Dictionary{System.Int32,Sdl.Core.LanguageProcessing.Segmentation.SegmentationInfo},System.Boolean)">
            <summary>
            Starts from a specified location.
            </summary>
            <param name="startLocation"></param>
            <param name="segmentationHints"> </param>
            <param name="skipsegments"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.ContentIterator.NextPotentialInlineElement">
            <summary>
            Advances to the next potential inline element, which may either be a text element / inline placeholder / tagpair include / lockedcontainer / revision marker
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.TagHelper.TagPairAtLocation(Sdl.FileTypeSupport.Framework.BilingualApi.Location)">
            <summary>
            Gets the tagpair at the given location.
            </summary>
            <param name="location">location</param>
            <returns>tagpair</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.TagHelper.AsTagPair(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData)">
            <summary>
            Gets the markup as a tagpair
            </summary>
            <param name="markup">markup</param>
            <returns>tagpair</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.TagHelper.RevisionMarkerAtLocation(Sdl.FileTypeSupport.Framework.BilingualApi.Location)">
            <summary>
            Gets the revision marker at the given location.
            </summary>
            <param name="location">location</param>
            <returns>revision marker</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.TagHelper.AsRevisionMarker(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData)">
            <summary>
            Gets the markup as a revision marker.
            </summary>
            <param name="markup">markup</param>
            <returns>revision marker</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.TagHelper.AsCommentMarker(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData)">
            <summary>
            Gets the markup as a comment marker.
            </summary>
            <param name="markup">markup</param>
            <returns>comment marker</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.TagHelper.LockedContentAtLocation(Sdl.FileTypeSupport.Framework.BilingualApi.Location)">
            <summary>
            Gets the locked container at the given location.
            </summary>
            <param name="location">location</param>
            <returns>locked container</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.TagHelper.AsLockedContent(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData)">
            <summary>
            Gets the locked container
            </summary>
            <param name="markup">markup</param>
            <returns>revision marker</returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.DataContentLocation">
            <summary>
            Describes a location in a data element of the filter framework. It combines the
            filter framework's <see cref="T:Sdl.FileTypeSupport.Framework.BilingualApi.Location"/>
            with an offset which points into a text element.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.DataContentLocation.#ctor(Sdl.FileTypeSupport.Framework.BilingualApi.Location,System.Int32)">
            <summary>
            Intializes a new instance with the specified values.
            </summary>
            <param name="location">The location</param>
            <param name="offset">An offset, which is only valid for locations which denote a 
            text element.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.DataContentLocation.ToString">
            <summary>
            <see cref="M:System.Object.ToString"/>
            </summary>
            <returns>A string representation of the object, for display purposes.</returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.DataContentLocation.Location">
            <summary>
            Gets or sets the location.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.DataContentLocation.Offset">
            <summary>
            Gets or sets the offset in the element <see cref="P:Sdl.Core.LanguageProcessing.Segmentation.DataContentLocation.Location"/> points to.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.Node">
            <summary>
            Represents a node in the Document tree (tag, text, container etc)
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsSegmentStarter">
            <summary>
            Indicates if this is the start of a segment
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsSegmentEnder">
            <summary>
            Indicates if this is the end of a segment
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.Split">
            <summary>
            does tree split, on node position the bilingual container split and synchronize the paragraph with the tree
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.Split(System.Boolean)">
            <summary>
            does tree split, on node position the bilingual container split and synchronize the paragraph with the tree - promotes data to parent
            </summary>
            <param name="promoteDataToParent">promotes data to parent if true</param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.SplitText(System.Int32,System.Boolean)">
            <summary>
            does a tree split at split position
            </summary>
            <param name="splitPosition">position to split from</param>
            <param name="leadingSpaces">indicates if leading spaces exist</param>
            <returns></returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.HasProcessedAlready">
            <summary>
            A flag to indicate if this node has already been processed
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.GetHashCode">
            <summary>
            Gets the hash code for this node
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.Equals(System.Object)">
            <summary>
            Equals override
            </summary>
            <param name="obj">object to compare with</param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.PromoteDataToParent(Sdl.Core.LanguageProcessing.Segmentation.Node,Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Promotes the data to the parent container
            </summary>
            <param name="newNode"></param>
            <param name="currentNode"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.CopyTreeData(Sdl.Core.LanguageProcessing.Segmentation.Node,Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Copies the data from an old tree segment into a new tree segment
            </summary>
            <param name="treeNode"></param>
            <param name="newNode"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.GetAncestorNodeBelowRoot">
            <summary>
            Gets the ancestor node just below the root
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsRoot">
            <summary>
            ////////////////////////////////////////////////////////////
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.Root">
            <summary>
            Root node of content
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.Parent">
            <summary>
            Parent of this node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.Next">
            <summary>
            Next sibling in chain
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.Previous">
            <summary>
            Previous sibling in chain
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.FirstChild">
            <summary>
            First child of this node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.First">
            <summary>
            First node in this chain
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.Last">
            <summary>
            Last node in this chain
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.Contains(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            returns true if this node contains the searchNode
            </summary>
            <param name="searchNode">Node to check for</param>
            <returns>true if the node being searched for is a descendant of this one (any level)</returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ContainsExcludeInside">
            <summary>
            Indicates if this node contains an exclude node which is a descendant (any level)
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ContainsOnlyMayExcludeInside">
            <summary>
            Indicates if this node contains only may exclude nodes which is a descendant (any level)
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ContainsIncludeInside">
            <summary>
            Indicates if this node contains an include node which is a descendant (any level)
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ContainsOnlyIncludeInside">
            <summary>
            Indicates if this node contains only include nodes which is a descendant (any level)
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ContainsOnlyIncludeContentInside">
            <summary>
            Indicates if this node contains only include content which is a descendant (any level)
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ContainsOnlyIncludeWithTextContentInside">
            <summary>
            Indicates if this node contains only include with text content which is a descendant (any level)
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsOnlyIncludeTagContentContainer">
            <summary>
            returns true in cases where we ONLY have include tags inside an include container - and no other content
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsOnlyIncludeWithTextNode">
            <summary>
            Indicates if this node in only an include node with text
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.CanIncludeAterText">
            <summary>
            Indicates if this node can be included after text nodes
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.CanIncludeBeforeText">
            <summary>
            Indicates if this node can be included before text nodes
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LastChild">
            <summary>
            returns the last child node of this node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.BranchIndex">
            <summary>
            Returns the branch index of this node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.BranchCount">
            <summary>
            Returns the number of nodes in this branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.HasPrevious">
            <summary>
            Indicates if this node has a previous sibling
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.HasNext">
            <summary>
            Indicates if this node has a subsequent sibling
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.HasParagraphNext">
            <summary>
            Indicates if this has a paragraph next
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.HasParent">
            <summary>
            Indicates if this node has a parent
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.HasChild">
            <summary>
            Indicates if this node has any children
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LockedContentHasChild">
            <summary>
            Indicates if this (locked content) has a child node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LockedContentOnlyInChainContainingText">
            <summary>
             If true, this locked content is the only thing in the chain (with the exception of any inconsequent items such as ILocationMarkers)
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LockedContentOnlyContainsWhitespace">
            <summary>
            Indicates if this (locked content) has only whitespace
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LockedContentOnlyContainsText">
            <summary>
            Indicates if this (locked content) contains only text.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsFirst">
            <summary>
            Indicates if this is the first node in the branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsLast">
            <summary>
            Indicates if this is the last node in the branch
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.Add">
            <summary>
            Adds a new node after this one in the branch
            </summary>
            <returns>added node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.Add(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Adds the given node after this one in the branch
            </summary>
            <param name="node">node to add after this one</param>
            <returns>added node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.Insert">
            <summary>
            Inserts a node before this node
            </summary>
            <returns>inserted node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.Insert(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Inserts the given node before this one
            </summary>
            <param name="node">node to insert</param>
            <returns>inserted node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.AddChild">
            <summary>
            Adds a child node at the end of the direct descendant's branch
            </summary>
            <returns>added node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.AddChild(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Adds the given node as a child at the end of the direct descendant's branch
            </summary>
            <param name="node">child node to add</param>
            <returns>added node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.InsertChild(System.Int32)">
            <summary>
            Inserts a child node at the given index in the direct descendant's branch
            </summary>
            <param name="index">index to insert child node at</param>
            <returns>inserted node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.InsertChild(System.Int32,Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Inserts the given node as a child at the given index in the direct descendant's branch
            </summary>
            <param name="index">index to insert child node at</param>
            <param name="node">node to insert as child</param>
            <returns>inserted node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.InsertNext">
            <summary>
            Inserts a new node after this one
            </summary>
            <returns>inserted node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.InsertNext(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Inserts the given node after this one
            </summary>
            <param name="node">node to insert</param>
            <returns>inserted node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.InsertPrevious">
            <summary>
            Inserts a new node before this one
            </summary>
            <returns>inserted node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.Cut">
            <summary>
            Cuts this node from the branch
            </summary>
            <returns>this node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.Remove">
            <summary>
            Removes this node from the branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ContainsOnlyWhitespace">
            <summary>
            Indicates if this node contains only whitespace
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsolatedTopLevelCanHideNode">
            <summary>
            returns the top isolated ancestor node above this one
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.TopLevelCanHideWithOneStarterEnderPair">
            <summary>
            returns the top-level node which has CanHide set and which has only one starter-ender pair
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsIsolatedNodeToRoot">
            <summary>
            returns true if all ancestor nodes are isolated all the way up to the parent node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.NonIsolatedTopLevelIncludeNodeInAncestorBranch">
            <summary>
            returns the top most include which is in a branch of other items and not an exclude
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.AncestorContainerChainIsEnder">
            <summary>
            returns true if any ancestor node is a segment ender
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.AncestorContainerChainIsStarter">
            <summary>
            returns true if any ancestor node is a segment starter
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.TopLevelIncludeNodeInAncestorBranch">
            <summary>
            returns the top-level include node in the ancestor chain above this node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideAnyIncludeContainer">
            <summary>
            indicates if this node is inside any may-include or include container
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideIncludeContainer">
            <summary>
            indicates if this node is inside an include container
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideTagInclude">
            <summary>
            indicates if this node is inside any tag marked as an include
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideExcludeContainer">
            <summary>
            indicates if this node is inside an exclude container
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsSegmentStarterEnderPair">
            <summary>
            indicates if this node is a segment starter-ender pair
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.NonIsolatedTopLevelNodeInAncestorBranch">
            <summary>
            returns the first parent which is in a branch of other items and not an exclude
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.PreviousEnderInBranch">
            <summary>
            returns the previous ender in the branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.PreviousEnderInTree">
            <summary>
            returns the previous ender in the tree
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.PreviousStarterInBranch">
            <summary>
            returns the previous starter in the branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ContainsSingleSegmentStarterEnderPair">
            <summary>
            indicates if this node contains a single starter-ender pair
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.PreviousContainerWithOneOrMoreStarterEnderPairsInsideOrStarterEnderPairInBranch">
            <summary>
            returns the previous container which has one or more starter-ender pairs inside or in this branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.PreviousContainerWithOneOrMoreStarterEnderPairsInsideInBranch">
            <summary>
            returns the container with one or more starter-ender pairs in this branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ContainersContainingStarterEnderPairsOrStarterEnderPairCount">
            <summary>
            returns the number of starter-ender pair containers or pairs
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.SegmentationHint">
            <summary>
            returns the segmentation hint for this node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.AnyExclude">
            <summary>
            indicates if this node is any type of exclude
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.AnyInclude">
            <summary>
            indicates if this node is any type of include
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LockedContentAnyInclude">
            <summary>
            indicates if this locked content is any type of include
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LockedContentInclude">
            <summary>
            indicates if this locked content is an include
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LockedContentIncludeWithText">
            <summary>
            indicates if this locked content is an include-with-text
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LockedContentExclude">
            <summary>
            indicates if this locked content is an exclude
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LockedContentAnyExclude">
            <summary>
            indicates if this locked content is an any-exclude
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.UniqueId">
            <summary>
            the unique ID for this node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsWordStop">
            <summary>
            indicates if this node is a word-stop
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsLockedContent">
            <summary>
            indicates if this node is locked content
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsSegment">
            <summary>
            indicates if this node is a segment
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LockedContentSegmentationHint">
            <summary>
            returns the segmentation hint for this node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.MarkedAsExclude">
            <summary>
            for future processing - this will allow previous operations in a given flow to mark this node for exclusion from a segment. Will aid future refactoring as once this node is marked this way
            it will never be included in a segment - mainly used for whitespace containing nodes at the moment
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.MayExclude">
            <summary>
            indicates if this node is a may-exclude
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.Exclude">
            <summary>
            indicates if this node is an exclude
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.Include">
            <summary>
            indicates if this node is an include
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IncludeWithText">
            <summary>
            indicates if this node is an include-with-text
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.CanHide">
            <summary>
            indicates if this node is a CanHide
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsTagPair">
            <summary>
            indicates if this node is a TagPair
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsAbstractTag">
            <summary>
            indicates if this node is an abstract tag
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsRevisionMarker">
            <summary>
            indicates if this node is a revision marker
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsPlaceholderTag">
            <summary>
            indicates if this node is a placeholder tag
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsText">
            <summary>
            indicates if this node is a text node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsLocationMarker">
            <summary>
            indicates if this node is a location marker
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsNonWhiteSpaceText">
            <summary>
            indicates if this node is non-whitepsace text
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.GetLeadingWhitespacesCount(System.String,System.Int32)">
            <summary>
            gets the leading whitespace count
            </summary>
            <param name="text">text to check</param>
            <param name="startIndex">index to check from</param>
            <returns>number of leading whitespace characters back from start index to first non-whitespace character</returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsWhitespace">
            <summary>
            indicates if this node is whitespace
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsWhitespaceToEndOfBranch">
            <summary>
            indicates if the following nodes to end of branch are all whitespace
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsWhitespaceToStartOfBranch">
            <summary>
            indicates if the preceding nodes to start of branch are all whitespace 
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideSegment">
            <summary>
            indicates if this node is inside a segment
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.InAnyTextFlow">
            <summary>
            indicates if this node has any text items in its flow
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsNodeSurroundedByWhitespaceInBranch">
            <summary>
            indicates if this node is surrounded by whitespace in this branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ParentIsLastContainerEnderInFlow">
            <summary>
            indicates if the parent is the last container-ender in this flow
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ParentIsFirstContainerStarterInFlow">
            <summary>
            indicates if the parent node (ancestors) is the first container-stater in the flow
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.NonWhitespaceTextItemsInBranchCount">
            <summary>
            returns the count of text items in the branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.EndersInBranchCount">
            <summary>
            returns the number of enders in the branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.StartersInBranchCount">
            <summary>
            returns the number of starters in the branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.DescendantStarters">
            <summary>
            returns the number of descendant starters
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.DescendantEnders">
            <summary>
            returns the number of descendant enders
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsContainer">
            <summary>
            indicates if this is a container
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.LeadingWhitespaceCount">
            <summary>
            returns the leading white-space count
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.TrailingWhitespaceCount">
            <summary>
            returns the trailing white-space count
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.TrailingWhitespaceSplitIndex">
            <summary>
            returns te split index for the trailing white-space
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.TextCount">
            <summary>
            returns the text count for this node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.Text">
            <summary>
            returns the text for this node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsCommentMarker">
            <summary>
            indicates if this node is a comment marker
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideTagContainer">
            <summary>
            indicates if this node is inside a tag container
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideRevisionContainer">
            <summary>
            indicates if this node is inside a revision container
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideCommentContainer">
            <summary>
            indicates if this node is inside a comment container
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideRevisionContainerWithNoMayExcludeInChain">
            <summary>
            indicates if this node is inside a revision container with no may-exclude in the chain
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideCommentContainerWithNoMayExcludeInChain">
            <summary>
            indicates if this node is inside a comment container with no may-exclude in the chain
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideTagIncludeContainer">
            <summary>
            indicates if this node is inside a tag container marked as include
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideTagAnyIncludeContainer">
            <summary>
            indicates if this node is inside a container marked as AnyInclude
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideAnyIncludeOrCanHideContainer">
            <summary>
            indicates if this node is inside a container marked as AnyInclude or CanHide
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideIncludeWithTextContainerWithMayExcludeInChain">
            <summary>
            Indicates if this node is inside an include-with-text container and a MayExclude exists also in the chain
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideSegmentEnder">
            <summary>
            indicates if this node is inside a segment ender
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideSegmentEnderAtEnd">
            <summary>
            indicates if this node is inside a segment ender at end of chain
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideSegmentStarter">
            <summary>
            indicates is this node is inside a segment starter
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideTagIncludeContainerWithMayExcludesInChain">
            <summary>
            indicates if this node is inside a Tag container with MayExcludes in the chain
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideIncludeRevisionOrMayExcludeContainer">
            <summary>
            indicates if this node is inside a revision with include set or a MayExclude container
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideTagStopContainer">
            <summary>
            indicates if this node is inside a TagStop container
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsAloneInMayExcludeContainer">
            <summary>
            indicates if this node is alone in a MayExclude container
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideMayExcludeOrExcludeContainer">
            <summary>
            indicates if this node is inside a MayExclude or Exclude container
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.IsInsideCanHideTagContainersUpToRoot">
            <summary>
            indicates if this node is inside a CanHide tag container (checks all ancestors up to root)
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.NextNonWhitespace">
            <summary>
            returns the next non-whitespace node in the branch
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.MoveSpaceOutsideContainer(System.Boolean)">
            <summary>
            Moves space(s) outside of the container
            </summary>
            <param name="isLeading"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.GetStarterParent">
            <summary>
            Gets the parent node which is a starter
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.ItemsEqual(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Checks if the nodes are equal
            </summary>
            <param name="other">node to compare against</param>
            <returns>true if the nodes are equal</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.PromoteStarter">
            <summary>
            promotes the parent node to a starter
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.PromoteEnder">
            <summary>
            promotes the parent node to an ender
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.ResetStartersAndEndersInContainer">
            <summary>
            resets all starters and enders in this container node
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.NextWhitespaceItemInBranch">
            <summary>
            returns the next whitespace item in a branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.NextStartingWhitespaceItemInSequence">
            <summary>
            returns the next starting whitespace item in a sequence of descendant nodes
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.PreviousEndingWhitespaceItemInSequence">
            <summary>
            returns the previous ending whitespace in a sequence of descendant nodes
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.PreviousExlcudeInBranch">
            <summary>
            returns the previous exclude in the branch
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.NextIncludeTagInBranch">
            <summary>
            returns the next include tag in the branch
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Node.NextEnderAppearsBeforeNextStarter(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Returns true if the next ender appears before the next starter
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.BranchOnlyContainsExludes">
            <summary>
            indicates if the branch only contains excludes
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.BranchContainsIncludes">
            <summary>
            indicates if the branch contains any Includes or IncludeWithTexts or Locked content includes
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.BranchContainsMultipleSegmentEnders">
            <summary>
            indicates if the branch contains multiple segment enders
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.ContainsOnlySegmentStarterEnderPairs">
            <summary>
            indicates if this container node contains only segment starter-ender pairs
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Node.NodeAfterPreviousEnderInBranchOrCurrentNode">
            <summary>
            returns the node after the previous ender in this branch or after the current node if it is an ender or contains an ender.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngine.GetNeutralPrefixLength(System.String,System.Int32)">
            <summary>
            Returns the length of a prefix which is to be considered "neutral" (i.e. leading whitespace). The
            default implementation checks for each character's IsWhitespace property.
            </summary>
            <param name="text">some input text</param>
            <param name="startIndex"></param>
            <returns>Length of a neutral prefix [0..text.Length]</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngine.GetNextChunk(System.String,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Get the next chunk of segment from the presented text.
            </summary>
            <param name="text">The input string</param>
            <param name="startIndex">The position in the input string at which to start the process</param>
            <param name="assumeEof">If true, a "hard EOF" is assumed and any remaining text is returned.</param>
            <param name="followedByWordBreakTag">If true, a word-breaking tag is following the available text.</param>
            <returns>The chunk of text (segment or neutral whitespace). null if none is present.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngine.GetAllMatches(System.String,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <param name="assumeEof"></param>
            <param name="followedByWordBreakTag"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineFactory.CreateSegmentationEngine(System.Globalization.CultureInfo)">
            <summary>
            Instantiates a segmentation engine, using the default rules loaded from the current assembly.
            </summary>
            <param name="culture">The culture to create a segmentation engine for.</param>
            <returns>A segmentation engine object</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineFactory.CreateSegmentationEngine(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor,System.String)">
            <summary>
            this is used by thirdParty clients with their own segmentation rule file
            </summary>
            <param name="culture"></param>
            <param name="accessor"></param>
            <param name="segmentationRulesFilePath"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineFactory.CreateSegmentationEngine(Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor,System.Globalization.CultureInfo)">
            <summary>
            Instantiates a segmentation engine for the specified culture. Segmentation rules are loaded
            through the specified resource data accessor.
            </summary>
            <param name="accessor">The resource data accessor to use to obtain the segmentation rules.</param>
            <param name="culture">The culture for which to instantiate the segmentation engine.</param>
            <returns>A segmentation engine which is parameterized from the rule set loaded through the
            specified resource data accessor.
            </returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner">
            <summary>
            The main class for calculating text enders based on the Segmentation Engine (Regex)
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.TextPart">
            <summary>
            Defines a TextPart in the text run which might require splits
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.TextPart.Item">
            <summary>
            Item containing text for this part
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.TextPart.WordStops">
            <summary>
            Tuple for Wordstops - int is offset of wordstop and bool is true if it is a TagPair
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.TextPart.#ctor">
            <summary>
            Constructor for TextPart
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.MatchDetails">
            <summary>
            Defines where matches occur in any given Text Part
            Splits will be needed for this Text Part if the matches are not at the boundaries
            The SplitPoints are relative to the Text Part - i.e. position 0 is at the beginning of the text
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.MatchDetails.TextPart">
            <summary>
            TextPart for this match
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.MatchDetails.CalculatedSplitPoints">
            <summary>
            The calculated split points for this Match
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.MatchDetails.IsWholeTextPartEnder">
            <summary>
            Indicates if this is a whole segment in this this textpart, i.e. no splits required
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.MatchDetails.TrailingWhitespaceCount">
            <summary>
            The number of trailing whitespace characters in this match
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.MatchDetails.#ctor">
            <summary>
            Constructor for MatchDetails
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.RunSegmentationEngine(Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngine,Sdl.Core.LanguageProcessing.Segmentation.Tree)">
            <summary>
            Main entry method for calculation of enders based on Regex Rules
            </summary>
            <param name="engine">Segmentation Engine</param>
            <param name="tree">Bilingual Content API tree model</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationEngineRunner.FindAllBreaks">
            <summary>
            Main method for finding all of the breaks in a text run
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationInfo.FollowedTagSpace">
            <summary>
            If set to true, text is followed by tag with IsWordStop = true
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationInfo.PrecededTagSpace">
            <summary>
            If set to true, text is preceded by tag with IsWordStop = true
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationInfo.IsInlineElement">
            <summary>
            If set to true, the element will be processed by the segmentor
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationInfo.TriggerSegmentCreation">
            <summary>
            Triggers segment creation
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationInfo.IsSegmentEnder">
            <summary>
            Indicates if it's a segment ender
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.SegmentationInfo.IsAfterSegmentEnder">
            <summary>
            Indicates if it's part of the segment; could follow last element in segment
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.SetLastEnder">
            <summary>
            Sets the last ender in the tree
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.SetRemainingEnders">
            <summary>
            Set the remaining enders after the last one
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.SetRemainingEnders(System.Boolean)">
            <summary>
            Sets all remaining text/placeholder enders
            </summary>
            <param name="handlePlaceholders">true if placeholders should be dealt with, otherwise text is handled</param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.GetNextIncludeEnders(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Gets any <pt/> or <pi/> nodes after the text node and returns the last one as a potential ender
            </summary>
            <param name="textNode"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.GetNextIncludeEndersIncludingWhitespace(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Gets any <pt/> or <pi/> nodes after the text node and returns the last one as a potential ender
            </summary>
            <param name="textNode"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.FindPreviousTextNode(Sdl.Core.LanguageProcessing.Segmentation.Node,System.Boolean)">
            <summary>
            Finds the previous text node from the given node's position
            </summary>
            <param name="node"></param>
            <param name="allowWhitespace"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.FindPreviousLockedContentIncludeNode(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Finds the previous locked content include node node from the given node's position
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.FindPreviousPlaceholderNode(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Finds the previous placeholder node from the given node's position
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HasExcludeBeforeTextInBranch(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Returns true if there is an exclude before text previous to the current node's position
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HasExcludeBoundary(Sdl.Core.LanguageProcessing.Segmentation.Node,Sdl.Core.LanguageProcessing.Segmentation.Node,System.Boolean,System.Boolean)">
            <summary>
            Indicates whether there is an exclude tag between two given nodes - the first node should be before the second node in order.
            </summary>
            <param name="textNode"></param>
            <param name="currentNode"></param>
            <param name="considerAnyExclude"></param>
            <param name="considerSegmentEnder"></param>
            <returns>true if there is an exclude tag between the two given nodes</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HasExcludeTagPairInChain(Sdl.Core.LanguageProcessing.Segmentation.Node,Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Checks to see if there is an exclude tag pair in the chain between the two given nodes.
            </summary>
            <param name="node">node below common parent for checking</param>
            <param name="commonParent">parent above node which could be a common parent of an other node as well</param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.GetCommonParent(Sdl.Core.LanguageProcessing.Segmentation.Node,Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Gets the common parent of 2 nodes
            </summary>
            <param name="item1"></param>
            <param name="item2"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.SetStarters">
            <summary>
            Sets the starters for the tree (works backwards in the tree)
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.FixUpAdjacentStarters">
            <summary>
            Fixes starters which are isolated (i.e. a starter followed by another starter - with no ender in between)
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.SetStartersEndersForTagPairs(Sdl.Core.LanguageProcessing.Segmentation.Node,System.Boolean@,Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Code for settings starter/enders in content representing just containers
            </summary>
            <param name="node"></param>
            <param name="setStarter"></param>
            <param name="currentStarter"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HasExcludeInBranch(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Returns true if this branch contains an exclude item
            </summary>
            <param name="node">node which branch check is based on</param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.SetStarters(System.Boolean)">
            <summary>
            Sets either text or placeholder starters
            </summary>
            <param name="handlePlaceholders"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.PreviousStarterAppearsBeforePreviousEnder(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Returns true if the previous starter appears before the previous ender
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HasEnderBetweenNodes(Sdl.Core.LanguageProcessing.Segmentation.Node,Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Returns true if there is an ender between two given nodes
            </summary>
            <param name="firstNode"></param>
            <param name="secondNode"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.GetPreviousPotentialStarter(Sdl.Core.LanguageProcessing.Segmentation.Node,System.Boolean)">
            <summary>
            Gets the previous potential starter from the given node (works backwards in the tree)
            </summary>
            <param name="node"></param>
            <param name="handlePlaceholders"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.GetPreviousIncludeStarters(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Gets any <pt/> or <pi/> nodes before the text node and returns the last one as a potential starter
            </summary>
            <param name="previousTextNode"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.ProcessLeadingSpaces(System.Boolean)">
            <summary>
            Checks to see if a split is needed for leading spaces and performs
            the operation if it is the case.
            <param name="moveOutsideContainer"></param>
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.ProcessTrailingSpaces(System.Boolean)">
            <summary>
            Checks to see if a split is needed for trailing spaces and performs the 
            operation if it is the case.
            <param name="moveOutsideContainer"></param>
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HandleContainerSplits">
            <summary>
            Handles all required types of splits for the containers
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HandleExcludeSplits">
            <summary>
            This splits include containers which contain excludes
            main case: <r0>Mary had a <pe/> little lamb.</r0>
            ignores <r0><pe/></r0> should have at least an ender inside container
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HandleStarterSplits">
            <summary>
            Handles required container splits based on starters
            main case: <tm>Seg1. Starter2</tm> ender2.  => starter2 is lower in tree than ender2 => split on Starter2 
            case1: <r0>ender1. ender2. ender3.</r0> => ro is starter and ender3 is ender, split on ender3 node, recursive for ender2 and ender1
            Note - if starter is inside an include container and ender is outside, at end of this, then we should promote starter to container - e.g.
            <ti>starter<ti></ti><l>55</l></ti>6 => <s><ti>starter<ti></ti><l>55</l></ti>6</s> - in this case the starter is: "<ti>starter<ti></ti><l>55</l></ti>"
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HasPreviousSiblingInChain(Sdl.Core.LanguageProcessing.Segmentation.Node,Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Returns true if any of the ancestor nodes up to the common parent have a previous sibling
            </summary>
            <param name="starter"></param>
            <param name="commonParent"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HandleStarterEnderPairsInContainerSplits">
            <summary>
            Split containers where we have the same number of starter/ender pairs inside
            Note: In cases such as <ti>StarterEnder. <ti>StarterEnder2. </ti></ti> we split to <ti>StarterEnder. </ti> and <ti><ti>StarterEnder2. </ti></ti>
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HandleStarterEnderGroupingsContainerSplits">
            <summary>
            This method does container splits for items such as <ti><ti>Starter [other non-exclude content]Ender. StarterEnder2. </ti></ti> => 
            <s><ti><ti>Starter [other non-exclude content]Ender.</ti></ti></s><s><ti><ti> StarterEnder2.</ti></ti></s>
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HandleEnderSplilts">
            <summary>
            Handles container splits based on enders
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HasNextSiblingInChain(Sdl.Core.LanguageProcessing.Segmentation.Node,Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Returns true if any of the ancestor nodes up to the common parent have a next sibling
            </summary>
            <param name="ender"></param>
            <param name="commonParent"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HasExcludeBetweenNodes(Sdl.Core.LanguageProcessing.Segmentation.Node@,Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            case <tm><tm>last</tm><pm/></tm> where "commonParent" is all text node is "last" and execlude item detected is the "pu"
            </summary>
            <param name="node"></param>
            <param name="commonParent"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.DoFinalPromotion">
            <summary>
            Promotes starters/enders to parent container if needed. This is the case where we have one item
            inside the container and it is a Starter or Ender (but not both at the same time)
            NOTE: WE ONLY PROMOTE TO UNDEFINED TAGS IF WE HAVE ISOLATED STARTERS OR ENDERS IN THEM WITH AN EXCEPTION
            WHEN THE ENDER TU IS THE LAST ITEM IN THE ROOT AND THE STARTER TU IS THE FIRST ITEM IN THE ROOT
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.IsInSameContainer(Sdl.Core.LanguageProcessing.Segmentation.Node,Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Checks to see if two nodes are in the same container
            </summary>
            <param name="starter"></param>
            <param name="ender"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.StarterAppearsBeforeEnderInBranch(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Returns true if a starter appears before an ender in the branch
            </summary>
            <param name="ender"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.FinalizeWhitespace">
            <summary>
            Handles cases of leading and trailing whitespace where the starter or ender is a promoted tag-pair.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HasStarterInChain(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Returns true if there is a starter in the ancestor chain
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.HasEnderInChain(Sdl.Core.LanguageProcessing.Segmentation.Node)">
            <summary>
            Returns true if there is an ender in the ancestor chain
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentationTreeManager.MoveToNextBoundary">
            <summary>
            Moves to the next potential Starter/Ender node
            Should be called after a Starter/Ender were on the same node.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.Segmentor">
            <summary>
            A Segmentor is a bilingual content processor which can be plugged into a filter framework
            processor chain. It breaks up the input into segments and modifies the document accordingly. 
            ToContent perform segmentation, set up a bilingual filter processor chain and insert an instance of
            this class appropriately. 
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.#ctor(Sdl.Core.LanguageProcessing.Segmentation.Settings)">
            <inheritdoc />
            <summary>
            Creates a new segmentor with the specified settings. Necessary resources are loaded from the 
            default location (usually the Lingua assembly).
            </summary>
            <param name="settings">The settings to use for the segmentation process.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.#ctor(Sdl.Core.LanguageProcessing.Segmentation.Settings,Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor)">
            <summary>
            Creates a new segmentor with the specified settings, using the specified resource data
            accessor to load abbreviations and other language resources. 
            </summary>
            <param name="settings">The settings to use for the segmentation process.</param>
            <param name="resourceDataAccessor">The resource data accessor to use to obtain required resources (segmentation rules, abbreviations, and the like). If null, uses the default resources.</param>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.Settings">
            <summary>
            The current segmentation settings. This does not include the resources (segmentation rules etc.).
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.SegmentCount">
            <summary>
            Returns the number of processed segments.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.ParagraphCount">
            <summary>
            Returns the number of processed paragraphs (trans-units). Only non-locked text units are counted.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.Initialize(Sdl.FileTypeSupport.Framework.BilingualApi.IDocumentProperties)">
            <summary>
            Interface method for the bilingual filter processor. Do not call directly.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.Initialize(System.Globalization.CultureInfo,System.String)">
            <summary>
            This method is intended to be used by third party
            </summary>
            <param name="culture"></param>
            <param name="ruleFilePath">full path of xml file containing the segmentation rules</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.Complete">
            <summary>
            Interface method for the bilingual filter processor. Do not call directly.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.SetFileProperties(Sdl.FileTypeSupport.Framework.BilingualApi.IFileProperties)">
            <summary>
            Interface method for the bilingual filter processor. Do not call directly.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.FileComplete">
            <summary>
            Interface method for the bilingual filter processor. Do not call directly.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.ProcessParagraphUnit(Sdl.FileTypeSupport.Framework.BilingualApi.IParagraphUnit)">
            <summary>
            Interface method for the bilingual filter processor. Do not call directly.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Segmentor.RemoveCommentMarkers(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupDataContainer)">
            <summary>
            Removes the comment markers from the given paragraph.
            </summary>
            <param name="paragraph">paragraph</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.SegmentorUtility.GetTrailingWhitespacesCount(System.String)">
            <summary>
            Returns length of trailing whitespace
            </summary>
            <param name="text">text to analyze</param>
            <returns>number of trailing whitespaces, counting backwards from the end of text</returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.Mode">
            <summary>
            Enumeration values which specify the segmentation mode.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.Mode.Disabled">
            <summary>
            No segmentation is performed.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.Mode.AllContentAsOneSegment">
            <summary>
            The complete content is treated as a single segment.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.Mode.SentenceSegmentation">
            <summary>
            Sentence boundaries are detected and used to specify segment boundaries.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.Mode.ParagraphSegmentation">
            <summary>
            Paragraph boundaries are detected and used to specify segment boundaries.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.TargetSegmentCreationMode">
            <summary>
            Enumeration values which specify whether and how target segments are created during segmentation.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.TargetSegmentCreationMode.None">
            <summary>
            Deletes target contents of the trans-unit (no segment structure will be created).
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.TargetSegmentCreationMode.CreateEmptyTarget">
            <summary>
            Creates empty segments in the trans-unit's target.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.TargetSegmentCreationMode.CopySource">
            <summary>
            Copies source segments into the trans-unit's target.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.Settings">
            <summary>
            Assembles settings which control the segmentation process.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.Settings.#ctor">
            <summary>
            Initializes a new instance with default values.
            <list type="table">
            <item><term><see cref="P:Sdl.Core.LanguageProcessing.Segmentation.Settings.Mode"/></term><description><see cref="F:Mode.SentenceSegmentation"/></description></item>
            <item><term><see cref="P:Sdl.Core.LanguageProcessing.Segmentation.Settings.TargetSegmentCreationMode"/></term><description><see cref="F:TargetSegmentCreationMode.CreateEmptyTarget"/></description></item>
            <item><term><see cref="P:Sdl.Core.LanguageProcessing.Segmentation.Settings.DontSegmentIfTargetExists"/></term><description><c>true</c></description></item>
            </list>
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Settings.TargetSegmentCreationMode">
            <summary>
            Gets or sets the target segment creation mode.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Settings.Mode">
            <summary>
            Gets or sets the segmentation mode.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.Settings.DontSegmentIfTargetExists">
            <summary>
            Gets or sets a flag which controls whether or not to segment if target
            content already exists in the paragraph.
            <para>If <c>true</c>, do not perform segmentation 
            if there is any content in the target paragraph, so that existing source and target 
            content of the paragraph will be preserved as is. If <c>false</c>, existing target
            content is overwritten by the segmentation process.</para>
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.SpacePositionEnum">
            <summary>
            Represents the position of whitespace within text
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.SpacePositionEnum.Leading">
            <summary>
            Whitespace is placed at the beginning of the text
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.SpacePositionEnum.Trailing">
            <summary>
            Whitespace is placed at the end of the text
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.T8.T8SegmentationEngine.GetAllMatches(System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets all matches for the given text run
            </summary>
            <param name="text">text run to analyse</param>
            <param name="assumeEof">true if assume EOF</param>
            <param name="followedByWordBreak">true if followed by WordBreak</param>
            <returns></returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Segmentation.TreeIterator.CurrentNode">
            <summary>
            The current node which the iterator is pointing to
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.TreeIterator.Next">
            <summary>
            Move to the next node in the tree - this allows traversal of the whole tree
            </summary>
            <returns>The next node</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.TreeIterator.Previous">
            <summary>
            Move to the previous node in the tree - this allows traversal of the whole tree
            </summary>
            <returns>The previous node</returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph">
            <summary>
            WordStopParagraph class represents a paragraph that can determine whether there is a word stop 
            before or after given text.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.#ctor(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupDataContainer)">
            <summary>
            Constructor that takes the given paragraph.
            </summary>
            <param name="paragraph">paragraph</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.HasWordStopBefore(Sdl.FileTypeSupport.Framework.BilingualApi.IText)">
            <summary>
            Determines whether there is a word stop before the given text.
            </summary>
            <param name="text">text</param>
            <returns>whether word stop before text</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.HasWordStopAfter(Sdl.FileTypeSupport.Framework.BilingualApi.IText)">
            <summary>
            Determines whether there is a word stop after the given text.
            </summary>
            <param name="text">text</param>
            <returns>whether word stop after text</returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor">
            <summary>
            WordStopVisitor class is responsible for visiting a paragraph, creating a flat markup list, and 
            being able to calculate whether there is a word stop before or after given text using the flat markup list.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor._flatMarkupList">
            <summary>
            After visting a paragraph, the flat markup list will contain a flattened markup list with
            all the markup. However, it will have the property that it will include the tag markup object 
            when the tag starts and when the tag ends. This property can be used to deduce whether 
            text is next to a word stop.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.VisitParagraph(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupDataContainer)">
            <summary>
            Visits the given paragraph.
            </summary>
            <param name="paragraph">paragraph</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.VisitCommentMarker(Sdl.FileTypeSupport.Framework.BilingualApi.ICommentMarker)">
            <summary>
            Visits the given comment marker.
            </summary>
            <param name="commentMarker">comment marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.VisitLocationMarker(Sdl.FileTypeSupport.Framework.BilingualApi.ILocationMarker)">
            <summary>
            Visits the given location.
            </summary>
            <param name="location">location</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.VisitLockedContent(Sdl.FileTypeSupport.Framework.BilingualApi.ILockedContent)">
            <summary>
            Visits the given locked content.
            </summary>
            <param name="lockedContent">locked content</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.VisitOtherMarker(Sdl.FileTypeSupport.Framework.BilingualApi.IOtherMarker)">
            <summary>
            Visits the given other marker.
            </summary>
            <param name="otherMarker">other marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.VisitPlaceholderTag(Sdl.FileTypeSupport.Framework.BilingualApi.IPlaceholderTag)">
            <summary>
            Visits the given placeholder tag.
            </summary>
            <param name="placeholderTag">placeholder tag</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.VisitRevisionMarker(Sdl.FileTypeSupport.Framework.BilingualApi.IRevisionMarker)">
            <summary>
            Visits the given revision marker.
            </summary>
            <param name="revisionMarker">revision marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.VisitSegment(Sdl.FileTypeSupport.Framework.BilingualApi.ISegment)">
            <summary>
            Visits the given segment.
            </summary>
            <param name="segment">segment</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.VisitTagPair(Sdl.FileTypeSupport.Framework.BilingualApi.ITagPair)">
            <summary>
            Visits the given tag pair.
            </summary>
            <param name="tagPair">tag pair</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.VisitText(Sdl.FileTypeSupport.Framework.BilingualApi.IText)">
            <summary>
            Visits the given text.
            </summary>
            <param name="text">text</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.VisitChildren(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupDataContainer)">
            <summary>
            Visits the children in the given container.
            </summary>
            <param name="container">container</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.HasWordStopBefore(Sdl.FileTypeSupport.Framework.BilingualApi.IText)">
            <summary>
            Determines whether there is a word stop before the given text.
            </summary>
            <param name="text">text</param>
            <returns>whether word stop before text</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.HasWordStopAfter(Sdl.FileTypeSupport.Framework.BilingualApi.IText)">
            <summary>
            Determines whether there is a word stop after the given text.
            </summary>
            <param name="text">text</param>
            <returns>whether word stop after text</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.HasWordStop(Sdl.FileTypeSupport.Framework.BilingualApi.IText,System.Int32)">
            <summary>
            Determines whether there is a word stop in the given direction from the given text.
            </summary>
            <param name="text">text</param>
            <param name="direction">direction</param>
            <returns>whether word stop in direction from text</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.IsWordStopTag(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractTag)">
            <summary>
            Determines whether the given abstract tag is a word stop tag.
            </summary>
            <param name="abstractTag">abstract tag</param>
            <returns>whether word stop tag</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.IsWordStopRevisionMarker(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupDataContainer,System.Int32)">
            <summary>
            Determines whether the given revision marker is a word stop revision marker.
            </summary>
            <remarks>
            Consider the following example: This is a [r]test[/r].[r] And this is another test[/r].
            In the second revision marker, the first character is a whitespace and so the second revision
            marker should be considered a word stop so that it segments after the first full stop.
            Similarly, consider the next example: This is a [r]test. [/r][r]And this is another test[/r].
            In the first revision marker, the last character is a whitespace and so the first revision
            marker should be considered a word stop so that it segments after the first full stop.
            </remarks>
            <param name="revisionMarker">revision marker</param>
            <param name="direction">direction</param>
            <returns>whether word stop revision marker</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopParagraph.WordStopVisitor.GetContainerText(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupDataContainer)">
            <summary>
            Gets the container text for the given container.
            </summary>
            <param name="container">container</param>
            <returns>container text</returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Segmentation.WordStopStringBuilder">
            <summary>
            WordStopStringBuilder class represents a simple string builder that can add word stops. A word stop is
            simply a space that denotes where there is a word boundary and can map between indexes with words stops
            to indexes without word stops.
            </summary>
            <example>
            Suppose WordStopStringBuilder was created and Append("Hello"), AppendWordStop(), and Append("World") was called.
            There are effectively two strings; one string with word marks and another string without word marks.
            
                               01234567890
            with word stops    Hello World
            without word stops HelloWorld
            
            ToString() will return the string with word marks.
            
            GetIndexWithoutWordStops maps between an index in the string with words stops and an index in the string without 
            word stops. So for example, GetIndexWithoutWordStops(8) will return 7.
            </example>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopStringBuilder.Append(System.String)">
            <summary>
            Appends the given text.
            </summary>
            <param name="text">text</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopStringBuilder.AppendWordStop">
            <summary>
            Appends a word stop.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopStringBuilder.GetIndexWithoutWordStops(System.Int32)">
            <summary>
            Gets the corresponding index without word stops given the index with word stops.
            </summary>
            <param name="indexWithWordStops">index with word stops</param>
            <returns>index without word stops</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Segmentation.WordStopStringBuilder.ToString">
            <summary>
            Gets the string representation of the string builder including word stops.
            </summary>
            <returns>string</returns>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentErrorCode.OK">
            <summary>
            Indicates success/no error.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentErrorCode.Other">
            <summary>
            Indicates that an unspecified error occurred.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentErrorCode.UndefinedOrInvalidLanguage">
            <summary>
            Indicates that a segment's or TU's language is not set or is invalid.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentErrorCode.NeutralLanguage">
            <summary>
            Indicates that a segment's culture is neutral, i.e. has no region-qualifier ("en")
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentErrorCode.EmptySegment">
            <summary>
            Indicates that a segment is empty.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentErrorCode.NoTextInSegment">
            <summary>
            Indicates that a segment consists only of tags and no text was found.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentErrorCode.TagInvalidTagAnchor">
            <summary>
            Indicates that a tag anchor is empty, not set, or invalid.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentErrorCode.TagAnchorAlreadyUsed">
            <summary>
            Indicates that a tag anchor in a segment has been used more than once for different tag instances.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentErrorCode.TagAnchorNotOpen">
            <summary>
            Indicates that a tag anchor assigned to an end tag hasn't yet been seen at the corresponding start tag.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentErrorCode.TagAnchorAlreadyClosed">
            <summary>
            Indicates that a tag anchor assigned to an end tag has already been used for a previously seen end tag.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentErrorCode.TagAnchorNotClosed">
            <summary>
            Indicates that a tag anchor occurred only at a start tag, but has no corresponding closing tag.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.SegmentTransferTools.FixUpPlaceholderIdsVisitor">
            <summary>
            This visitor fixes up Placeholder IDs in the target. It looks for placeholders inside tag pairs which have been matched
            to tag pairs in the source. It then visits each placeholder in turn and looks for a corresponding one in the source tag pair. If found
            it clones the properties from the source placeholder to the target placeholder. This ensures the IDs etc match.
            These placeholders in the target have IDs which have been artificially generated i.e. starting with "pm".
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.SegmentTransferTools.SegmentTransferHelper">
            <summary>
            Class defines helper functions for transfering segments between documents
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.SegmentTransferHelper.MergeSegmentsInParagraphUnit(Sdl.FileTypeSupport.Framework.BilingualApi.ISegment,System.Int32)">
            <summary>
            Merge segments in Paragraph Unit.
            (Currently merging segments across paragraph units is not supported.
            </summary>
            <param name="firstSegment">First segment to merge in paragraph unit/</param>
            <param name="toMerge">number of segments to merge starting from first segment</param>
            <returns>number of segments merged</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.SegmentTransferHelper.RenumberTagIds(Sdl.FileTypeSupport.Framework.NativeApi.ParagraphUnitId,Sdl.FileTypeSupport.Framework.BilingualApi.IParagraph)">
            <summary>
            Renumbers the tag ids.
            </summary>
            <param name="paragraphUnitId">paragraph unit id</param>
            <param name="paragraph">paragraph</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sdl.Core.LanguageProcessing.SegmentTransferTools.SegmentTransferHelper.FixTags(System.Collections.Generic.IEnumerable{Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData},Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer,System.Collections.Generic.List{Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractTag})" -->
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.SegmentTransferHelper.FixNotFoundTags(Sdl.FileTypeSupport.Framework.BilingualApi.ISegment,Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer)">
            <summary>
            Fixes problems with tag pairs wrongly set as placeholders in the bilingual translated file. The metod transforms "pairs" of placeholder tags into tag pairs.
            These tags cannot be usually be matched by the <see cref="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.SegmentTransferHelper.FixTags(System.Collections.Generic.IEnumerable{Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData},Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer,System.Collections.Generic.List{Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractTag})">FixTags method</see> and they have TagId starting with "pm".        
            </summary>
            <param name="targetContainer"></param>
            <param name="tagContainer"></param>
            <returns>True if there were any changes to the tags; otherwise False.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.SegmentTransferHelper.GenerateArtificalTagId(Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer)">
            <summary>
            Generate unique artificial tag id.
            This method is used when we cannot find corresponding tag in source segment (this should never happen).
            </summary>
            <param name="tagContainer">tagContainer with existing tags, used do determine if autogenerated tag id is unique.</param>
            <returns>New artificial tag id</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.SegmentTransferHelper.RestoreSubsegments(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractTag,Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractTag)">
            <summary>
            Restore subsegment data for tag.
            </summary>
            <param name="tagToUpdate">Updated Tag.</param>
            <param name="sourceTag">Tag containing source data.</param>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer">
            <summary>
            Purpose for this class is to:
            1) Enable matching tags between two segments. This is important when transferring target segment
            from reference document to target segment in source (translated bilingual) document - all segment ids (and properties)
            must match between source and target segment to ensure valid bilingual document.
            2) enable tag matching for aligning subsegment 
            references in Perfect Match. It is used when transferred translation (target) segment from
            original document contains subegment references, which become invalid in the new document.
            The invalid subsegment references are fixed by matching corresponding tags between source and 
            target segment and getting proper subsegment references from source tag.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer._markupData">
            <summary>
            Corresponding markup data
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer._subsegmentReferencesOnly">
            <summary>
            Indicates if container should store tags with
            subsegment references only
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.Tags">
            <summary>
            Exposes tags collection
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.#ctor(System.Boolean)">
            <summary>
            Creates new instance of TagContainer class
            </summary>
            <param name="subsegmentReferencesOnly">true if container should store tags with subsegment references only</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.Initialize(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData)">
            <summary>
            Initializes tag container with markup data.
            </summary>
            <param name="source">Markup data to initialize with</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.FindRelatedTag(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractTag)">
            <summary>
            Find corresponding tag in abstract markup data
            </summary>
            <param name="tagToFind">Tag to find.</param>
            Note: Special correspondence measure is introduced to find similar tags
            <returns>Returns corresponding tag in source or null.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.FindRelatedTag(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractTag,System.Collections.Generic.IEnumerable{Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractTag},System.Boolean@)">
            <summary>
            
            </summary>
            <param name="tagToFind"></param>
            <param name="alreadyFound"></param>
            <param name="isnewTag"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.Contains(System.String)">
            <summary>
            Check for existance of tag with given tagId 
            </summary>
            <param name="tagId">Tag id to look for.</param>
            <returns>True if tag with given tag id exists</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.AreTagPairsIdentical(Sdl.FileTypeSupport.Framework.BilingualApi.ITagPair,Sdl.FileTypeSupport.Framework.BilingualApi.ITagPair)">
            <summary>
            Compare all properties of tag pairs and returns true if all are identical
            </summary>
            <param name="item1">First tag pair to compare.</param>
            <param name="item2">Second tag pair to compare.</param>
            <returns>True if tag pairs are identical.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.NormalizeTagText(System.String)">
            <summary>
            Normalize whitespaces in string
            </summary>
            <param name="tagText">text to normalize.</param>
            <returns>Normalized text.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.ArePlaceholdersIdentical(Sdl.FileTypeSupport.Framework.BilingualApi.IPlaceholderTag,Sdl.FileTypeSupport.Framework.BilingualApi.IPlaceholderTag)">
            <summary>
            Compare all properties of placeholders and returns true if all are identical
            </summary>
            <param name="item1">First placeholder to compare.</param>
            <param name="item2">Second placeholder to compare.</param>
            <returns>true if placeholders tags are identical.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.isLocalizableContentEqual(Sdl.FileTypeSupport.Framework.Native.AbstractTagProperties,Sdl.FileTypeSupport.Framework.Native.AbstractTagProperties)">
            <summary>
            copied filetypesupport AbstractTagProperties.Equals method, without base.Equals and tagID compare code
            </summary>
            <param name="item1"></param>
            <param name="item2"></param>
            <returns></returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector">
            <summary>
            Implementation of visitor pattern to collect all tags in markup data container.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector._tags">
            <summary>
            Collection of tags found during visiting markup data.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector._subsegmentReferencesOnly">
            <summary>
            Indicates if container should store tags with
            subsegment references only
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.Tags">
            <summary>
            Gets collection of tags found
            during visiting markup data.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.#ctor(System.Boolean)">
            <summary>
            Creates new instance of Tag Collector class
            </summary>
            <param name="subsegmentReferencesOnly">indicates if tag with subsegment references should only be stored.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.LocateTags(Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData)">
            <summary>
            Collects all tags.
            </summary>
            <param name="abstractMarkupData">Markup data to process</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.VisitChildren(System.Collections.Generic.IEnumerable{Sdl.FileTypeSupport.Framework.BilingualApi.IAbstractMarkupData})">
            <summary>
            Iterates all sub items of container (IAbstractMarkupDataContainer)
            </summary>
            <param name="container">container to be visted</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.VisitCommentMarker(Sdl.FileTypeSupport.Framework.BilingualApi.ICommentMarker)">
            <summary>
            Visit comment marker
            </summary>
            <param name="commentMarker">comment marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.VisitLocationMarker(Sdl.FileTypeSupport.Framework.BilingualApi.ILocationMarker)">
            <summary>
            Visit location marker
            </summary>
            <param name="location">location marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.VisitLockedContent(Sdl.FileTypeSupport.Framework.BilingualApi.ILockedContent)">
            <summary>
            Visit locked content 
            </summary>
            <param name="lockedContent">locked content marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.VisitOtherMarker(Sdl.FileTypeSupport.Framework.BilingualApi.IOtherMarker)">
            <summary>
            Visit other marker
            </summary>
            <param name="marker">other marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.VisitPlaceholderTag(Sdl.FileTypeSupport.Framework.BilingualApi.IPlaceholderTag)">
            <summary>
            Visit and store placeholder tag.
            </summary>
            <param name="tag"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.VisitRevisionMarker(Sdl.FileTypeSupport.Framework.BilingualApi.IRevisionMarker)">
            <summary>
            Visit revision marker.
            </summary>
            <param name="revisionMarker">revision marker</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.VisitSegment(Sdl.FileTypeSupport.Framework.BilingualApi.ISegment)">
            <summary>
            Visit segment.
            </summary>
            <param name="segment">Segment to be visited.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.VisitTagPair(Sdl.FileTypeSupport.Framework.BilingualApi.ITagPair)">
            <summary>
            Visit tag pair.
            </summary>
            <param name="tagPair">Tag pair to be visited.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.SegmentTransferTools.TagContainer.TagCollector.VisitText(Sdl.FileTypeSupport.Framework.BilingualApi.IText)">
            <summary>
            Visit text.
            </summary>
            <param name="text">Text to be visited.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Stemming.CachingStemmer.#ctor(Sdl.Core.LanguageProcessing.Stemming.IStemmer)">
            <summary>
            Constructs a new cache around the specified stemmer.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Stemming.CachingStemmer.Stem(System.String)">
            <inheritdoc />
            <summary>
            See <see cref="M:Sdl.Core.LanguageProcessing.Stemming.IStemmer.Stem(System.String)" />
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Stemming.DumbStemmer">
            <inheritdoc />
            <summary>
            A dumb stemmer doesn't know anything about languages and simply uses some heuristics
            to pseudo-stem its input, such as lowercasing.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Stemming.DumbStemmer.Stem(System.String)">
            <inheritdoc />
            <summary>
            Returns the stem form of a word
            </summary>
            <param name="word">The word.</param>
            <returns>The stem form of word.</returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Stemming.IStemmer">
            <summary>
            Basic interface for stemming.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Stemming.IStemmer.Stem(System.String)">
            <summary>
            Returns the stem form of the specified word.
            </summary>
            <param name="word">The word.</param>
            <returns>The stem form of word.</returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Stemming.IStemmer.Signature">
            <summary>
            Return a signature to distinguish results from this version of this stemmer
            (typically used to detect reindex requirements)
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Stemming.StemmingRule">
            <summary>
            Represents a stemming rule.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Stemming.StemmingRule.StemAction">
            <summary>
            The action to be applied by the rule.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Stemming.VersionStemmingRule">
            <inheritdoc />
            <summary>
            Pseudo-rule used as least-disruptive way to allow stemming rule files to contain version info.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Stemming.StemmingRuleParser.Add(System.String)">
            <summary>
            Read a stemming _Rule from a string in the old TRADOS format. 
            </summary>
            <param name="rule">The textual _Rule</param>
            <returns>A new stemming _Rule, parsed from the input string</returns>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Stemming.StemmingRuleSet.DefaultMinimumWordLength">
            <summary>
            don't apply substitutions for words shorter than this:
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Stemming.StemmingRuleSet.DefaultMinimumStemLength">
            <summary>
            don't apply a substitution when the stem becomes shorter
            than this:
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Stemming.StemmingRuleSet.DefaultMinimumStemPercentage">
            <summary>
            don't appliy a substitution when the stem becomes shorter
            than this percent of the original word's length:
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Stemming.StemmingRuleSet.DefaultMaximumRuleApplications">
            <summary>
            a _Rule is not applied when the stem becomes shorter than
            any of the both parameters
            </summary>
            <summary>
            how many rules may be applied? - avoid recursion
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.DateTimePattern.ParseOutput(System.String)">
            <summary>
            Parses the output of the FST traversal as specified by the automaton. See <see cref="T:Sdl.Core.LanguageProcessing.Tokenization.DateTimePatternComputer"/>
            for details.
            </summary>
            <param name="fstOutput">The FST's output as a string</param>
            <returns>A DateTime object, default(DateTime) on failure.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.DateTimePatternComputer.GetDateTimeLanguageResources(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.LanguageMetadata,System.Collections.Generic.List{System.String},System.Boolean)">
            <summary>
            Creates compiled FST data for recognizing <see cref="F:Sdl.LanguagePlatform.Core.Tokenization.TokenType.Date"/> and 
            <see cref="F:Sdl.LanguagePlatform.Core.Tokenization.TokenType.Time"/> tokens, including any custom formats specified, 
            as well as any default formats for the culture unless excluded by <paramref name="customOnly"/>. 
            Also creates the corresponding FSTEx data for each such FST, for runtime use and later alteration of the FST.
            </summary>
            <param name="ci">The culture to use when generating the FST</param>
            <param name="customPatterns">Any custom date/time patterns to use. See <see href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings"/></param>
            <param name="customOnly">If true, only the formats in <paramref name="customPatterns"/> custom formats are 
            considered when building the FST; no default formats for the culture are added</param>
            <param name="lm">The language metadata to use if including default formats</param>
            <remarks>
            Not all the elements defined in <see href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings"/> 
            are supported by the FST compiler. Use <see cref="M:Sdl.Core.LanguageProcessing.Tokenization.DateTimePatternComputer.GetSupportedDateTimeFormatElements"/> to get the set of 
            elements that are.
            </remarks>
            <returns>A list of FST and FSTEx pairs, one for each <see cref="T:Sdl.LanguagePlatform.Core.Resources.LanguageResourceType"/> created.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.DateTimePatternComputer.CreateDateTimeFsTs(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.LanguageMetadata,Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,Sdl.Core.LanguageProcessing.DateTimeFSTEx},System.Boolean)">
            <summary>
            Creates FSTs, or loads pre-computed FSTs, capable of recognizing the specified <see cref="T:Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType"/> types of value,
            based on format strings specified by calendars for the culture concerned, or based on custom format strings, or both
            </summary>
            <param name="culture">The culture whose calendars are used for creating FSTs, or which is used to load from the resource accessor</param>
            <param name="lm"></param>
            <param name="types"></param>
            <param name="customPatterns">Any custom patterns to be used when creating FSTs</param>
            <param name="dateTimeFstExMap">The list of patterns actually used when creating new FSTs, or that were used to create the FSTs loaded 
            from the resource (if that information is available). See <see cref="M:Sdl.Core.LanguageProcessing.Tokenization.DateTimePatternComputer.ComputeFsTsForSingleCalendar(Sdl.LanguagePlatform.Core.LanguageMetadata,Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,System.Collections.Generic.List{System.String},System.Collections.Generic.IDictionary{Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,Sdl.Core.LanguageProcessing.DateTimeFSTEx},System.Boolean)"/>
            for more info.</param>
            <param name="customOnly">If true, only <paramref name="customPatterns"/> is used to create new FSTs</param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.DateTimePatternComputer.LoadPatterns(Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,System.Collections.Generic.IDictionary{Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,Sdl.Core.LanguageProcessing.DateTimeFSTEx})">
            <summary>
            Attempts to load the FSTs from the resource accessor. 
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.DateTimePatternComputer.GetFsTsForMultipleCalendarsAndTypes(Sdl.LanguagePlatform.Core.LanguageMetadata,Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,System.Collections.Generic.List{System.String},System.Collections.Generic.Dictionary{Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,Sdl.Core.LanguageProcessing.DateTimeFSTEx},System.Boolean)">
            <summary>
            Creates a list of <see cref="T:Sdl.Core.LanguageProcessing.Tokenization.CalendarDateTimePatterns"/>, one per calendar, where each contains an FST for each unique <see cref="T:Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType"/>
            identified in the format strings used
            </summary>
            <param name="lm"></param>
            <param name="types">The <see cref="T:Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType"/> types for which to create FSTs</param>
            <param name="customPatterns">A list of custom date/time format strings to use when creating FSTs, e.g. "dd-MM-yyy"</param>
            <param name="dateTimeFstExMap">The list of format strings actually used to create the FSTs. See <see cref="M:Sdl.Core.LanguageProcessing.Tokenization.DateTimePatternComputer.ComputeFsTsForSingleCalendar(Sdl.LanguagePlatform.Core.LanguageMetadata,Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,System.Collections.Generic.List{System.String},System.Collections.Generic.IDictionary{Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,Sdl.Core.LanguageProcessing.DateTimeFSTEx},System.Boolean)"/>
            for more information</param>
            <param name="customOnly">If true, only the custom format strings are used to create the FSTs, not any format strings found in a calendar</param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.DateTimePatternComputer.ComputeFsTsForSingleCalendar(Sdl.LanguagePlatform.Core.LanguageMetadata,Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,System.Collections.Generic.List{System.String},System.Collections.Generic.IDictionary{Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType,Sdl.Core.LanguageProcessing.DateTimeFSTEx},System.Boolean)">
            <summary>
            Creates FSTs for date/time recognition, using a single calendar, based either on the 
            format specifications found in that calendar, or custom format specifications, or both
            </summary>
            <param name="lm"></param>
            <param name="types">The types of date/time format for which to retrieve format strings from the calendar</param>
            <param name="customPatterns">Any custom format strings to use e.g. "d-MM-yyy"</param>
            <param name="dateTimeFstExMap">Populated with the complete list of format strings that were used to create the FSTs</param>
            <param name="customOnly">If true, only the contents of <paramref name="customPatterns"/> will be used to create FSTs, not format strings in any calendar</param>
            <returns>A <see cref="T:Sdl.Core.LanguageProcessing.Tokenization.CalendarDateTimePatterns"/> having one <see cref="T:Sdl.Core.LanguageProcessing.Tokenization.DateTimePattern"/> for each <see cref="T:Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType"/> for which at least
            one format string was found. </returns>
            <remarks>Each <see cref="T:Sdl.Core.LanguageProcessing.Tokenization.DateTimePattern"/> in the return contains the FST able to process all valid formats for that <see cref="T:Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType"/>.
            Although <see cref="T:Sdl.Core.LanguageProcessing.Tokenization.DateTimePattern"/> has a <see cref="P:Sdl.Core.LanguageProcessing.Tokenization.DateTimePattern.FormatString"/> property, this is not relevant for those objects, since
            each contains a combined FST that may process many such format strings. This means the FST can be used to recognize a DateTime value, but does not 
            alone identify the format string. The contents of <paramref name="customPatterns"/> is the list of format strings actually used to create the FSTs,
            being any format strings in the calendar or in <paramref name="customPatterns"/> for which a <see cref="T:Sdl.LanguagePlatform.Core.Tokenization.DateTimePatternType"/> could be identified (meaning
            format strings such as "dd-MM" will be considered invalid and ignored). Once a DateTime value has been recognized, if it's necessary to change the
            value but keep it in the same format, the format string is needed as an argument of ToString.</remarks>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.DateTimePatternComputer.ClassifyPattern(System.String)">
            <summary>
            Determines the pattern type of a date/time format string.
            </summary>
            <param name="formatString">A format string, as returned from a culture's date/time pattern list.</param>
            <returns>The pattern type, which may be "Unknown" for unsupported patterns.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.DateTimePatternComputer.CheckPatternConsistency(System.String,System.String)">
            <summary>
            Checks whether the format string can successfully be used both to render a DateTime value to string, then parse that string back to a DateTime value
            </summary>
            <param name="formatString">The date/time format string to test</param>
            <param name="langCode">The language code for the culture in which the format string is used, e.g. "en-US"</param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.DefaultFallbackRecognizer.IsHardTokenTerminator(System.String,System.Int32,Sdl.Core.LanguageProcessing.Tokenization.RecognizerSettings)">
            <summary>
            Returns true iff the char at s[p] is not allowed inside a (simple) token
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Tokenization.FSTMatch">
            <inheritdoc />
            <summary>
            A match which includes the output produced by an FST.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.FSTRecognizer.ComputeMatches(System.String,System.Int32,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Computes the matches for the current FST, given the input.
            </summary>
            <param name="s">The input string</param>
            <param name="startOffset">The offset in the input string where to start the matching process</param>
            <param name="ignoreCase">If <c>true</c>, the matching process will ignore case differences. If <c>false</c>, 
            symbols must match literally.</param>
            <param name="cap">If <c>&gt;0</c>, the number of matches will
            be limited to that number. Otherwise, all matches will be returned.</param>
            <param name="keepLongestMatchesOnly">If <c>true</c>, only the (group of) longest matches
            is kept in the result set, even if the number in that group is smaller than <paramref name="cap"/>. If <c>false</c>, 
            matches of all lengths are kept in the result set.</param>
            <returns>The matches, sorted by decreasing coverage length, or <c>null</c> if no matches
            were found.</returns>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.TrailingContext.None">
            <summary>
            Indicates that no particular trailing context is required.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.TrailingContext.RequireNonwordCharacter">
            <summary>
            Indicates that a trailing nonword character is always required, independent of the culture
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.TrailingContext.Auto">
            <summary>
            Indicates that a trailing nonword character is required if the current culture uses
            blanks as word separators, but that no such character is required if that's not the
            case.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Tokenization.IRecognizerTextFilter">
            <summary>
            Implemented by recognizers that are potentially expensive to run, e.g. because they can't
            perform 'early exit' based on first-character filter, so have to run on lots
            of candidates
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.IRecognizerTextFilter.ExcludeText(System.String)">
            <summary>
            Returns true if the span of text could not possibly contain a token matching this recognizer
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.NumberSeparatorMode.CultureDefault">
            <summary>
            use culture's default separators
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.NumberSeparatorMode.Swapped">
            <summary>
            Use culture's swapped default separators
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.NumberSeparatorMode.EnUS">
            <summary>
            Use separators of en-US ('.' decimal, ',' group separator)
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.MeasureFSTRecognizer.#ctor(Sdl.Core.LanguageProcessing.Tokenization.RecognizerSettings,System.Globalization.CultureInfo,System.Int32,Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor)">
            <summary>
            Attempts to get the compiled FST from the resources, and if that fails, will create it from scratch 
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.NumberFSTRecognizer.#ctor(Sdl.Core.LanguageProcessing.Tokenization.RecognizerSettings,System.Globalization.CultureInfo,System.Int32,Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor)">
            <summary>
            Attempts to get the compiled FST from the resources, and if that fails, will create it from scratch 
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.NumberFormatData.AddSeparatorCombination(System.String,System.String,System.Boolean)">
            <summary>
            <param name="augmentGroupSeparators">If true, blanks/nbsp's will be interchangeable</param>
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.NumberPatternComputer.AllowTrailingSign">
            <summary>
            If true, trailing signs are enabled for cultures where the number format info
            suggests that signs may also appear "after" the numeric part, which is the case
            for right-to-left ("bidi") cultures. If that's the case, the generated recognizer
            will support both leading as well as trailing signs. If false, only leading signs are supported.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.NumberPatternComputer.SupportNonstandardGrouping">
            <summary>
            If true, non-standard digit groupings (such as in Hindi) are supported. If false,
            only the standard three-digit grouping is supported.	
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.NumberPatternComputer.DoAddEnusSeparators(System.Globalization.CultureInfo)">
            <summary>
            Returns true if the decimal and group separators are not those of en-US
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.NumberPatternComputer.GetNumberFormatData(System.Globalization.CultureInfo,System.Boolean,System.Boolean)">
            <summary>
            <param name="augmentWhitespaceGroupSeparators">If true, blanks/nbsp's will be interchangeable</param>
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.NumberPatternComputer.GetMeasureNumberAndCurrencyLanguageResources(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.LanguageMetadata,System.Collections.Generic.List{Sdl.Core.LanguageProcessing.Tokenization.SeparatorCombination},System.Collections.Generic.Dictionary{System.String,Sdl.LanguagePlatform.Core.Tokenization.CustomUnitDefinition},System.Collections.Generic.List{Sdl.LanguagePlatform.Core.Tokenization.CurrencyFormat},System.Boolean,System.Boolean)">
            <summary>
            Creates compiled FST data for recognizing <see cref="F:Sdl.LanguagePlatform.Core.Tokenization.TokenType.Measurement"/> 
            and <see cref="F:Sdl.LanguagePlatform.Core.Tokenization.TokenType.Number"/> tokens, including any custom number 
            separator combinations specified and any custom unit types specified, as well as the default separator 
            and unit types for the culture, unless excluded by <paramref name="customSeparatorsOnly"/> and 
            <paramref name="customUnitsOnly"/>. Also creates the corresponding FSTEx data.
            </summary>
            <param name="ci">The culture to use when building the FST</param>
            <param name="customSeparatorCombinations">Any custom separator combinations to use</param>
            <param name="customUnits">Any custom units to use</param>
            <param name="customSeparatorsOnly">If true, only the separators defined in <paramref name="customSeparatorCombinations"/> 
            are considered when building the FST; no other culture-based separators are added</param>
            <param name="customUnitsOnly">If true, only unit types defined in <paramref name="customUnits"/> are considered 
            when building the FST, no other culture-based units are added</param>
            <param name="currencyFormats">A list of <see cref="T:Sdl.LanguagePlatform.Core.Tokenization.CurrencyFormat"/> objects determining how to recognize/localize currency values. If null or empty, defaults for the culture are used.</param>
            <param name="lm">The language metadata to use if including default separators</param>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.Recognizer._cultureSpecificTextConstraints">
            <summary>
            Optionally set by derived classes to configure per-culture text constraints
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Recognizer.GetSignature(System.Globalization.CultureInfo)">
            <summary>
            Return a signature string that can be used to distinguish between different versions of this recognizer,
            typically for detecting reindex requirements
            </summary>
            <param name="culture">The culture of the text to which the recognizer is being applied</param>
            <returns></returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Tokenization.Recognizer.OverrideFallbackRecognizer">
            <summary>
            If <c>true</c>, tokens recognized by this recognizer will override the tokens recognized
            by the default fallback recognizer, even if they are shorter. If <c>false</c>, the longest
            match will win.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Recognizer.VerifyContextConstraints(System.String,System.Int32,Sdl.LanguagePlatform.Core.Tokenization.Token)">
            <summary>
            Checks whether additional terminating context constraints are fulfilled and returns true if so, or if none are set.
            </summary>
            <param name="s">The string being tokenized</param>
            <param name="p">The position in the string of the character immediately following the candidate token</param>
            <param name="t">Optionally, the candidate token itself (passed to any culture-specific handler set - see <see cref="F:Sdl.Core.LanguageProcessing.Tokenization.Recognizer._cultureSpecificTextConstraints"/>)</param>
            <returns></returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Tokenization.Tokenizer">
            <summary>
            An engine which splits a stream of characters into a stream of tokens (usually words).
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Tokenization.Tokenizer.Signature">
            <summary>
            Return a signature that can be used to distinguish between differing tokenizers,
            whether they differ in code implementation or runtime configuration,
            typically used to detect reindexing requirements.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Tokenizer.AdjustNumberRangeTokenization(System.Collections.Generic.List{Sdl.LanguagePlatform.Core.Tokenization.Token})">
            <summary>
            Deal with cases like "Perform the action 10-20 times", by changing the unhelpful
            tokenization {"10", "-20"} into {"10", "-", "20"}. See LCC-9402
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Tokenizer.ApplyVariableRecognizer(System.String,Sdl.LanguagePlatform.Core.Tokenization.Token,System.Collections.Generic.List{Sdl.LanguagePlatform.Core.Tokenization.Token}@,System.Int32@)">
            <summary>
            Method used to recognize variables, by merging tokens that 
            </summary>
            <param name="s"></param>
            <param name="token"></param>
            <param name="result"></param>
            <param name="startChainTokenPosition"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Tokenizer.CheckForVariableTokens(Sdl.LanguagePlatform.Core.Tokenization.Token,System.String,System.Collections.Generic.List{Sdl.LanguagePlatform.Core.Tokenization.Token}@,System.Int32@)">
            <summary>
            Verify possible token chains that  form variables and merge them in one "Variable" token
            check interval between tokens [result[_startChainTokenPosition],  winningToken], winningToken is last added token in results
            </summary>
            <param name="winningToken"></param>
            <param name="s"></param>
            <param name="result"></param>
            <param name="startChainTokenPosition"></param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Tokenizer.MergelastTokens(System.String,System.Int32,System.Collections.Generic.List{Sdl.LanguagePlatform.Core.Tokenization.Token}@,System.Int32,System.Globalization.CultureInfo)">
            <summary>
            Merge tokens interval [result[indexToUpdate+1], result[nrTokens - 1]] and replace with a Variable token
            </summary>
            <param name="variableCandidate"></param>
            <param name="nrTokens"></param>
            <param name="result"></param>
            <param name="indexToUpdate"></param>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Tokenization.TokenizerParameters">
            <summary>
            Encapsulates the settings which control the behavior and the output of a <see cref="T:Sdl.Core.LanguageProcessing.Tokenization.Tokenizer"/>.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Tokenization.TokenizerParameters.Signature">
            <summary>
            Return a signature that can distinguish between this set of parameters
            and another that either differs in implementation in such a way as to change the output,
            or differs in runtime configuration in such a way as to affect the output,
            typically for identifying reindex requirements.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.TokenizerParameters.#ctor(Sdl.Core.LanguageProcessing.Tokenization.TokenizerSetup,Sdl.LanguagePlatform.Core.Resources.IResourceDataAccessor)">
            <summary>
            Initialize the tokenizer parameters from the tokenizer setup information. 
            The resource data accessor is only used for retrieving variable values.
            </summary>
            <param name="setup">The tokenizer setup to use</param>
            <param name="accessor">A resource data accessor, to initialize the variables list</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.TokenizerParameters.AddRecognizer(Sdl.Core.LanguageProcessing.Tokenization.Recognizer)">
            <summary>
            Add a recognizer to the collection. 
            </summary>
            <param name="r">The recognizer</param>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Tokenization.TokenizerSetup">
            <summary>
            A simple, fully serializable class which holds a tokenizer's settings. This is just
            a data container for serialization which excuses that all fields are public.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.TokenizerSetup.CreateWhitespaceTokens">
            <summary>
            
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.TokenizerSetup.BreakOnWhitespace">
            <summary>
            
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Tokenization.TokenizerSetup.CultureName">
            <summary>
            Gets or sets the language in the form of a locale string.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.TokenizerSetup.SeparateClitics">
            <summary>
            If true, selected clitics will be stripped by the fallback recognizer,
            for romance languages (leading, l' d') as well as English (trailing 've 's, 'm, 'll n't 're). 
            Note that this is not yet fully implemented. Also, separated clitics are not always correctly
            classified as stop words.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.TokenizerSetup.BuiltinRecognizers">
            <summary>
            Gets or sets a value representing which recognizers are enabled.
            </summary>
        </member>
        <member name="F:Sdl.Core.LanguageProcessing.Tokenization.TokenizerSetup.TokenizerFlags">
            <summary>
            Gets or sets a value providing flags to control tokenizer behaviour
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.TokenizerSetupFactory.Create(System.Globalization.CultureInfo)">
            <summary>
            Create a default tokenizer setup object for the given culture. Will recognize acronyms, 
            dates, measurements, numbers, and time expressions, and uses default fallback recognizers.
            </summary>
            <param name="culture"></param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.TokenizerSetupFactory.Create(System.Globalization.CultureInfo,Sdl.LanguagePlatform.Core.Tokenization.BuiltinRecognizers,Sdl.LanguagePlatform.Core.Tokenization.TokenizerFlags)">
            <summary>
            Create a default tokenizer setup object for the given culture, using the specified 
            recognizers and the fallback recognizer
            </summary>
            <param name="culture"></param>
            <param name="recognizers"></param>
            <param name="flags">Flags affecting tokenizer behaviour</param>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FSATransition.Equals(System.Object)">
            <summary>
            <see cref="M:System.Object.Equals(object)"/>
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns>true if the specified object is equal to the current object;
            otherwise, false.
            </returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FSATransition.GetHashCode">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FSATransition.CompareTo(Sdl.Core.LanguageProcessing.Tokenization.Transducer.FSATransition)">
            <inheritdoc />
            <summary>
            Defines an order on transitions. They are sorted by the source state ASC, 
            then by input symbol ASC, then by target state ASC.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.Disjunct(System.Collections.Generic.IList{Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST})">
            <summary>
            Builds the disjunction of the current automaton with the rhs ones.
            </summary>
            <param name="alternatives">The other alternatives</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.ComputeReachableStates">
            <summary>
            Reachable states are states which can be reached by the transitive closure of any 
            transition, starting at the start state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.IsCyclic">
            <summary>
            true iff any transition from any start-reachable state points "back" (i.e. there
            are loops). This includes state-local loops (a transition from state x to itself).
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.MergeSimpleFinalStates">
            <summary>
            Merge all final states with only incoming transitions into one state
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.EliminateEpsilonTransitions">
            <summary>
            Eliminate "true" epsilon transitions (where both input and output are eps). Note that 
            partial eps transitions (either input or output is eps) will remain.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.MakeDeterministic">
            <summary>
            Attempts to make the automaton deterministic. Note that it's never fully deterministic on 
            a single band, since one symbol may always be eps.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.ComputeProductiveStates">
            <summary>
            Productive states are states from which, by following any sequence of transitions, a 
            final state can be reached. Note that productive states are not necessarily reachable.
            </summary>
            <returns>The list of productive states of the automaton</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.Clean">
            <summary>
            Deletes unproductive and then non-reachable states.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.ComputeStateClosure(System.Int32,System.Boolean,Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.TransitionProperty)">
            <summary>
            Compute the transitive closure (i.e. the list of states) which can be reached from the 
            start state by following transitions with the given property. 
            </summary>
            <param name="startState">The state at which to start the computation.</param>
            <param name="includeStartState">Whether or not the start state is included in the result.</param>
            <param name="prop">The property a transition must fulfill to be followed further.</param>
            <returns>A list of state IDs</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.GetBinary">
            <summary>
            Get a binary representation of the automaton, useful for storing it in a file.
            </summary>
            <returns>A byte array which represents a compiled, binary form of the FST</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST.IsIdentical(Sdl.Core.LanguageProcessing.Tokenization.Transducer.FST)">
            <summary>
            Detects whether the two FSTs are identical. Identity is stronger than equality in that
            the state numbering and all other information must be the same.
            </summary>
            <param name="other">The FST to compare to.</param>
            <returns>true if both FSTs are identical, false otherwise</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FSTTransition.Equals(System.Object)">
            <summary>
            <see cref="M:System.Object.Equals(object)"/>
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns>true if the specified object is equal to the current object;
            otherwise, false.
            </returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FSTTransition.GetHashCode">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.FSTTransition.CompareTo(Sdl.Core.LanguageProcessing.Tokenization.Transducer.FSTTransition)">
            <inheritdoc />
            <summary>
            Defines an order on transitions. They are sorted by the source state ASC, 
            then by input symbol ASC, then by output symbol ASC, then by target
            state ASC.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.Label.Matches(System.Char,System.Collections.Generic.List{System.Int32},System.Boolean)">
            <summary>
            Tests whether the character c is matched by a list of symbols (which is e.g. a FIRST() set).
            </summary>
            <param name="c">The character to test</param>
            <param name="symbols">The list of symbols. If the list is not sorted, it will be sorted.</param>
            <param name="ignoreCase"></param>
            <returns>true iff the character is contained in the symbol list</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.Label.Equals(System.Object)">
            <summary>
            <see cref="M:System.Object.Equals(object)"/>
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns>true if the specified object is equal to the current object;
            otherwise, false.
            </returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.Label.GetHashCode">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.Label.ToString">
            <summary>
            <see cref="M:System.Object.ToString"/>
            </summary>
            <returns>A string representation of the object, for display purposes.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.Matcher.Match(System.String,System.Boolean,Sdl.Core.LanguageProcessing.Tokenization.Transducer.Matcher.MatchMode,System.Int32,System.Boolean)">
            <summary>
            Finds and collects all matches.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.MatchState.Traverse(System.String,Sdl.Core.LanguageProcessing.Tokenization.Transducer.FSTTransition,Sdl.Core.LanguageProcessing.Tokenization.Transducer.Matcher.MatchMode,System.Boolean)">
            <summary>
            Attempts to traverse the specified transition, given the current match state. 
            </summary>
            <param name="input">The string input</param>
            <param name="t">The transition to probe</param>
            <param name="mode">The match mode</param>
            <param name="ignoreCase"></param>
            <returns>The new match state or null if the transition cannot be traversed</returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Tokenization.Transducer.Node">
            <summary>
            An internal helper class which represents an RX expression tree
            which later will be converted into an FST
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.Node.ToString">
            <summary>
            <see cref="M:System.Object.ToString"/>
            </summary>
            <returns>A string representation of the object, for display purposes.</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.Parser.Scan(System.Boolean)">
            <summary>
            Reads the next input symbol from the expression, sets _CurrentSymbol
            and, if that's a Symbol.Char, also _CurrentChar
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Tokenization.Transducer.State">
            @author Oli
            
            Ported from Genesis/java on 03-JAN-2006 (Oli)
            
            Represents an FST state
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Tokenization.Transducer.State.IsDeterministic">
            <summary>
            Determines whether the state is deterministic. It is not deterministic if it has any
            outgoing true eps transitions or two transitions have the same input/output label.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.IWordBoundaryFinder">
            <summary>
            Abstraction of implementations that allow for strings of non-separated characters
            to be divided into words. This also allows mock implementations for testing.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.StandardWordBoundaryFinder">
            <inheritdoc />
            <summary>
            Default word-boundary finder that uses the ICU library.
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.TrieIterator`2">
            <inheritdoc />
            <summary>
            An abstract iterator which can be used to iterate through a <see cref="T:Sdl.Core.LanguageProcessing.Trie`2" />. The
            iterator can be thought of pointing to a node in the trie, or to <c>null</c> if 
            the iterator's current position is invalid.
            </summary>
            <typeparam name="T">The trie's element type (<see cref="T:Sdl.Core.LanguageProcessing.Trie`2" />)</typeparam>
            <typeparam name="V">The trie's value type (<see cref="T:Sdl.Core.LanguageProcessing.Trie`2" />)</typeparam>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.TrieIterator`2.Traverse(`0)">
            <summary>
            Traverse the trie from the current node, given the <paramref name="key"/>.
            </summary>
            <returns>true if the iteration was successful, false otherwise (in which case
            the iterator should no longer be used).</returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.TrieIterator`2.IsValid">
            <summary>
            Returns true if the iterator points to a valid location in the trie, and false
            otherwise (in which case the iterator should no longer be used).
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.TrieIterator`2.Value">
            <summary>
            Returns the value associated with the current node. If the iterator
            does not point to a valid location, an exception may be thrown or the 
            default value for <typeparam name="V"/>
            may be returned.
            <remarks>It is recommended to call <see cref="P:Sdl.Core.LanguageProcessing.TrieIterator`2.IsValid"/> to check whether
            the current location is valid before this method is used.</remarks>
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.TrieIterator`2.IsFinal">
            <summary>
            Returns true if the current node is a final node in the trie, which means that it
            has associated values. Note that final nodes are not identical to leaf nodes: 
            you can continue iteration even from a final node.
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.TrieIterator`2.Path">
            <summary>
            Returns the path traversed so far.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.TrieIterator`2.GetEnumerator">
            <inheritdoc />
            <summary>
            Returns an enumerator which can be used to enumerate all items "at or below" the 
            current node.
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.TrieIterator`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
            <summary>
            Returns an enumerator which can be used to enumerate all items "at or below" the 
            current node.
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.TrieEnumerator`2">
            <inheritdoc />
            <summary>
            Provides an enumerator which can be used to iterate through a trie's leaf nodes.
            </summary>
            <typeparam name="T">The label type</typeparam>
            <typeparam name="V">The leaf (value) type</typeparam>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.TrieEnumerator`2.Current">
            <inheritdoc />
            <summary>
            See <see cref="P:System.Collections.IEnumerator.Current" />
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.TrieEnumerator`2.Dispose">
            <inheritdoc />
            <summary>
            See <see cref="M:System.IDisposable.Dispose" />
            </summary>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.TrieEnumerator`2.System#Collections#IEnumerator#Current">
            <inheritdoc />
            <summary>
            See <see cref="P:System.Collections.IEnumerator.Current" />
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.TrieEnumerator`2.MoveNext">
            <inheritdoc />
            <summary>
            See <see cref="M:System.Collections.IEnumerator.MoveNext" />
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.TrieEnumerator`2.Reset">
            <inheritdoc />
            <summary>
            See <see cref="M:System.Collections.IEnumerator.Reset" />
            </summary>
        </member>
        <member name="T:Sdl.Core.LanguageProcessing.Trie`2">
            <inheritdoc />
            <summary>
            A trie structure which contains sequences of T (an element type) which define paths to nodes of type V (the value type). For example,
            if <typeparamref name="T" /> is <c>char</c>, and <typeparamref name="V" /> is <c>int</c>, you can use a trie to map sequences of 
            characters (strings) to integer numbers.
            <para>Instances of this class are not thread-safe for parallel insertions, but are safe to use
            from multiple threads if only lookups are performed.</para>
            </summary>
            <remarks>Tries are relatively slow to build (slower than e.g. HashSet&lt;string&gt;) but are fast 
            during lookup.</remarks>
            <typeparam name="T">The element type. Paths are expressed as sequences of T.</typeparam>
            <typeparam name="V">The node value type. Used to store information at final positions.</typeparam>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Trie`2.#ctor">
            <summary>
            Constructs a new Trie. 
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Trie`2.Clear">
            <summary>
            Empties the trie and removes all nodes.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Trie`2.GetIterator">
            <summary>
            Returns a <see cref="T:Sdl.Core.LanguageProcessing.TrieIterator`2"/> which can be used to traverse the trie. The
            iterator will "point" to the trie's root node initially.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Trie`2.Add(System.Collections.Generic.IList{`0},`1)">
            <summary>
            Adds or extends the node at path <paramref name="s"/>. If the path already points to 
            a final node, its value will be overwritten. 
            </summary>
            <param name="s">The key sequence</param>
            <param name="nodeValue">A value to add or set on the final node for <paramref name="s"/>.s</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Trie`2.Update(System.Collections.Generic.IList{`0},`1)">
            <summary>
            Updates the value at the final node for the key sequence <paramref name="s"/>
            to <paramref name="nodeValue"/>. If the key sequence is not contained
            in the trie, an exception is thrown.
            </summary>
            <param name="s">The key sequence</param>
            <param name="nodeValue">The new node value to be set for the final node for <paramref name="s"/>.</param>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Trie`2.Lookup(System.Collections.Generic.IList{`0})">
            <summary>
            Returns the node value at path <paramref name="s"/> of the trie, or default(<typeparamref name="V"/>) if the
            trie does not contain the key sequence.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Trie`2.Contains(System.Collections.Generic.IList{`0})">
            <summary>
            Returns true if a node at path <paramref name="s"/> exists and has values. 
            </summary>
            <param name="s">The key sequence to look up</param>
            <returns>true if the trie contains the key sequence <paramref name="s"/>
            and has values for that key sequence.</returns>
            <remarks>Note that the method also returns <c>false</c> if the key
            sequence is contained in the trie, but does not have any associated
            values.</remarks>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Trie`2.Contains(System.Collections.Generic.IList{`0},`1@)">
            <summary>
            Returns true if a node at path <paramref name="s"/> exists and has values. 
            </summary>
            <param name="s">The key sequence to look up</param>
            <param name="value"></param>
            <returns>true if the trie contains the key sequence <paramref name="s"/>
            and has a value for that key sequence.</returns>
        </member>
        <member name="P:Sdl.Core.LanguageProcessing.Trie`2.IsEnumerationSupported">
            <summary>
            Returns <c>true</c> if enumeration is supported by this instance, and <c>false</c> otherwise.
            If enumeration is not supported, calling <see cref="M:Sdl.Core.LanguageProcessing.Trie`2.GetEnumerator"/> (or using a <c>foreach</c> 
            statement) will raise an exception.
            </summary>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Trie`2.GetEnumerator">
            <inheritdoc />
            <summary>
            Obtains an enumerator which can be used to enumerate the trie's leaf nodes, providing
            access to the path to the leaf and the value at that leaf.
            <para>Before obtaining an enumerator, you should first call <see cref="P:Sdl.Core.LanguageProcessing.Trie`2.IsEnumerationSupported" />. If that
            returns <c>false</c>, enumeration is unsupported and calling  <see cref="M:Sdl.Core.LanguageProcessing.Trie`2.GetEnumerator" /> will
            raise an exception.</para>
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="M:Sdl.Core.LanguageProcessing.Trie`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
            <summary>
            Obtains an enumerator which can be used to enumerate the trie's leaf nodes, providing
            access to the path to the leaf and the value list at the leaf.
            </summary>
            <returns>An enumerator</returns>
        </member>
    </members>
</doc>
